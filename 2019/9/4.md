# 2019.9.4

## 如何优雅的关闭Java线程池

####  线程中断

在介绍线程池关闭之前，先介绍下Thread的interrupt。

在程序中，我们是不能随便中断一个线程的，因为这是极其不安全的操作，我们无法知道这个线程正运行在什么状态，它可能持有某把锁，强行中断可能导致锁不能释放的问题；或者线程可能在操作数据库，强行中断导致数据不一致混乱的问题。正因此，JAVA里将Thread的stop方法设置为过时，以禁止大家使用。

一个线程什么时候可以退出呢？当然只有线程自己才能知道。

所以我们这里要说的Thread的interrrupt方法，本质不是用来中断一个线程。是将线程设置一个中断状态。

当我们调用线程的interrupt方法，它有两个作用：

1、如果此线程处于阻塞状态(比如调用了wait方法，io等待)，则会立马退出阻塞，并抛出InterruptedException异常，线程就可以通过捕获InterruptedException来做一定的处理，然后让线程退出。

2、如果此线程正处于运行之中，则线程不受任何影响，继续运行，仅仅是线程的中断标记被设置为true。所以线程要在适当的位置通过调用isInterrupted方法来查看自己是否被中断，并做退出操作。

Tip：
如果线程的 interrupt 方法先被调用，然后线程调用阻塞方法进入阻塞状态，InterruptedException异常依旧会抛出。如果线程捕获InterruptedException异常后，继续调用阻塞方法，将不再触发InterruptedException异常。

#### 线程池的关闭

线程池提供了两个关闭方法，shutdownNow和shuwdown方法。

shutdownNow方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。

shutdown方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。

使用shutdownNow方法，可能会引起报错；使用shutdown方法可能会导致线程关闭不了、所以当我们使用shutdownNow方法关闭线程池时，一定要对任务里进行异常捕获。当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。

调用完shutdownNow和shuwdown方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用awaitTermination方法进行同步等待。

## Runtime.getRuntime().availableProcessors()

`Runtime.getRuntime().availableProcessors()`方法返回可用处理器的Java虚拟机的数量。

`Runtime.getRuntime().availableProcessors()`也并非都能返回你所期望的数值。比如说，在我的双核1-2-1机器上，它返回的是2，这是对的。不过在我的1-4-2机器 上，也就是一个CPU插槽，4核，每个核2个超线程，这样的话会返回8。不过我其实只有4个核，如果代码的瓶颈是在CPU这块的话，我会有7个线程在同时竞争CPU周期，而不是更合理的4个线程。如果我的瓶颈是在内存这的话，那这个测试我可以获得7倍的性能提升。

不过这还没完！Java Champions上的一个哥们发现了一种情况，他有一台16-4-2的机器 （也就是16个CPU插槽，每个CPU4个核，每核两个超线程，返回的值居然是16！从我的i7 Macbook pro上的结果来看，我觉得应该返回的是16`*`4`*`2=128。
在这台机器上运行Java 8的话，它只会将通用的线程池的并发数设置成15。正如 Brian Goetz 所指出的，“虚拟机其实不清楚什么是处理器，它只是去请求操作系统返回一个值。同样的，操作系统也不知道怎么回事，它是去问的硬件设备。硬件会告诉它一个值，通常来说是硬件线程数。操作系统相信硬件说的，而虚拟机又相信操作系统说的。”