# 计算机基础

## 走进0与1的世界

#### 为何负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32 位）和长整型（64 位）数上，假如在整型数上移动的位数是32 位，**无论是否带符号位以及移动方向，均为本身**。因为移动的位数是个mod 32 的结果，即 `35 >> 1` 与 `35 >> 33` 是一样的结果。如果是长整型， mod 64，即 `35 << 1` 与`35 << 65`的结果是一样的。负数在无符号往右移动 63 位时，除最右边为1， 左边均为0，达到最小值1，如果 >>> 64，则为其原数值本身。

```java
public class Test{

	public static void main(String[] args) {
		int a = 35;
		int b = -35;

		System.out.println("==========正数============");
		System.out.println(a >>> 1);

		System.out.println(a >>> 27);
		System.out.println(a >>> 28);
		System.out.println(a >>> 29);
		System.out.println(a >>> 30);
		System.out.println(a >>> 31);
		System.out.println(a >>> 32);
		System.out.println(a >>> 33);
		System.out.println("==========负数============");
		System.out.println(b >>> 1);

		System.out.println(b >>> 27);
		System.out.println(b >>> 28);
		System.out.println(b >>> 29);
		System.out.println(b >>> 30);
		System.out.println(b >>> 31);
		System.out.println(b >>> 32);
		System.out.println(b >>> 33);
	}
	
}
```

结果：

```
==========正数============
17	//1
0	//27
0
0
0
0	//31
35	//32
17
==========负数============
2147483630	//1
31	//27
15
7
3
1	//31
-35	//32
2147483630
```

#### 异或运算 ^

异或运算没有短路功能，一般在哈希算法中用于离散哈希值，对应的位上不一样才是1。



## 浮点数

#### 浮点数表示

当前业界流行的浮点数标准是 `IEEE754` ，该标准规定了4种浮点数类型：单精度、双精度、延伸单精度、延伸双精度。前两种类型是最常用的。

**浮点数无法表示零值。**

范围：

| 精度       | 字节数 | 正数取值范围             | 负数取值范围             |
| ---------- | ------ | ------------------------ | ------------------------ |
| 单精度类型 | 4      | `1.4e-45 至 3.4e+38`     | `-3.4e+38 至 -1.4e-45`   |
| 双精度类型 | 8      | `4.9e-324 至 1.798e+308` | `1.798e+308 至 4.9e-324` |

#### 阶码位

IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。

移码是将一个真值在数轴上正向平移一个偏移量之后得到的，即 [x]~移~ = x + 2^n-1^ （n为x的二进制位数，含符号位）。移码的几何意义是把真值映射到一个正数域，其特点是可以直观地反映两个真值的大小，即移码大的真值也大。

> 真值 = 阶码 - （2^n-1^ - 1）

#### 为什么偏移值为2^n-1^ - 1 而不是 2^n-1 呢？

因为8个二进制位能表示指数的取值范围为 [-128,127] ，现在将指数变成移码表示，即将区间 [-128,127] 正向平移到正数域，区间里的每个数都需要加上 128 ，从而得到阶码范围为[0,255 ] 。

由于计算机规定阶码全为 0 或全为 1 两种情况被当作特殊值处理（全 0 被认为是机器零，全 1 被认为是无穷大），去除这两个特殊值，阶码的取值范围变成了 [1,254] 。

如果偏移量不变仍为128 的话，则根据换算关系公式 [x]~阶~ = x + 128 得到指数的范围变成[-127,126]，指数最大只能取到 126 ，显然会缩小浮点数能表示的取值范围。

所以 IEEE754 标准规定单精度的阶码偏移量为 2^n-1^ - 1 （即 127 ），这样能表示的指数范围为[-126,127]，指数最大值能取到 127。

0**111-1111-0**111-1111-1111-1111-1111-1111

为了节约存储空间，将符合规格化位数的首个1省略，所以尾数表面上是23位，却表示了24位二进制数。

#### 加减运算
对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。

1. 零值检测。 检查参加运算的两个数中是否存在为 0 的数（ 0  在浮点数是一
种规定，即阶码与尾数全为 0 ），因为浮点数运算过程比较复杂，如果其中一个数为 0,可以直接得出结果。
2. 对阶操作。 通过比较阶码的大小判断小数点位置是否对齐。IEEE754 规定对阶的移动方向为向右移动，即选择阶码小的数进行操作。
3. 尾数求和。
4. 结果规格化。如果运算的结果仍然满足规格化形式，则无须处理，否则需要通过尾数位的向左或右移动调整达到规格化形式。尾数位向右移动称为右规，反之称为左规。
5. 结果舍入。在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃， 从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。

#### 浮点数使用
在使用浮点数时推荐使用**双精度**，使用单精度由于表示区间的限制 ，计算结果会出现微小的误差。
1. 在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储。
2. 在要求精确表示小数点 n 位的业务场景下，比如圆周率要求存储小数点后 1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推荐采用数组保存小数部分的数据。
3. 在比较浮点数时，由于存在误差，往往会出现意料之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。
4. 在数据库中保存小数时，推荐使用 `decimal` 类型，禁止使用 float 类型和 double 类型。因为这两种类型在存储的时候，存在精度损失的问题。

## 字符集与乱码
实现 Unicode 的编码格式有三种 UTF-8 UTF-16 UTF-32，UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为对Unicode 的压缩方式。根据二八原则，常用文字只占文字总数的 20% 左右。

在日常开发中，字符集如果不兼容则会造成乱码。

乱码的出现场景并不止于编码环境中，还有网页展示、文本转换、文件读取等。数据流从底层数据库到应用层，到Web 服务器，再到客户端显示，每位开发工程师都会碰到字符乱码的问题，排查起来是一个比较长的链路。

数据库是存储字符之源，在不同层次上都能够设置独立的字符集，如服务器级别、 schema 级别、表级别甚至列级别。为了减少麻烦，所有情况下的字符集设置最好是一致的。

## CPU与内存
越往 CPU 核心靠近，存储越贵，速度越快。越往下，存储越便宜、速度越慢，当然容量也会更大。
程序员们最害怕的 OOM（Out Of Memory）通常来源于由于不恰当的编码方式而导致内存的资源耗尽 ，虽然现代内存的容量已经今非昔比，但仍然是可以在秒级内耗尽所有内存资源的。
内存的抽象就是线性空间内的字节数组，通过下标访问某个特定位置的数据，比如 C 语言使用 malloc（） 进行内存的分配，然后使用指针进行内存的读与写；而以 Java 为代表的编程语言，内存就交给 JVM 进行自动分配与释放，这个过程
称为垃圾回收机制。虽然垃圾回收机制能为程序员减负，但如果不加节制的话，同样会耗尽内存资源。

## TCP / IP

p29

------------------------

RPC 服务集群的注册中心与服务提供方、消费方之间，消息服务集群的缓存服务器和消费者服务器之间，应用后台服务器和数据库之间，都会使用**连接池**来提升性能。
数据库连接池负责分配、管理和释放连接，这是一种以内存空间换取时间的策略，能够明显地提升数据库操作的性能。但如果数据库连接管理不善，也会影响到整个应用集群的吞吐量。连接池配置错误加上**慢SQL** ，就像屋漏偏逢连夜雨，可以瞬间让一个系统进入服务超时假死宕机状态。

> 导致慢 SQL 的原因：
> 1. SQL编写问题
   >- 与索引相关的规则：
     - 字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；
     - mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；
     - 不要在字段前面加减运算；
     - 字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；
     - like % 在前面用不到索引；
     - 根据联合索引的第二个及以后的字段单独查询用不到索引；
     - 不要使用 select * ；
     - 排序请尽量使用升序 ;
     - or 的查询尽量用 union 代替 （InnoDB）；
     - 复合索引高选择性的字段排在前面；
     - order by / group by 字段包括在索引当中减少排序，效率会更高。
   >- 尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；
   - 分页语句 limit 的问题；
   - 删除表所有记录请用 truncate，不要用 delete；
   - 不让 mysql 干多余的事情，如计算；
   - 输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；
   - 在 Innodb上用 select count( * )，因为 InnoDB 会存储统计信息；
   - 慎用 Order by rand()。
>2. 锁
>3. 业务实例相互干绕对 IO/CPU 资源争用
>4. 服务器硬件
>5. MYSQL BUG
>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的分析诊断工具有：mysql dumpslow ;  mysql profile ;  mysql explain

连接数的创建是受到服务器操作系统的`fd`（文件描述符）数量限制的。创建更多的活跃连接，就需要消耗更多的`fd`，系统默认单个进程可同时拥有 1024 个`fd`，该值虽然可以适当调整，但如果无限制地增加，会导致服务器在`fd`的维护和切换上消耗过多的精力，从而降低应用吞吐量。

在双十一的场景里，应用服务器的全链路上不论是连接池的峰值处理，还是应用之间的调用频率，都会有相关的限流措施和降级预案。

一般可以把连接池的最大连接数设置在 30 个左右 理论上还可以设置更大的值，但是 DBA（Database Adiministrator） 一般不会允许，因为往往只有出现了慢 SQL 才需要使用更多的连接数。这时候通常需要优化应用层逻辑或者创建数据库索引，而不是一昧地采用加大连接数这种治标不治本的做法。极端情况下甚至会导致数据库服务不晌应，进而影响其他业务。

从经验上来看，在数据库层面的请求应答时间必须在100ms 以内，秒级的 SQL查询通常存在巨大的性能提升空间，有如下应对方案：

 1. 建立高效且合适的索引。

 2. 排查连接资源未显式关闭的情形。要特别注意在 ThreadLocal 或流式计算中使用数据库连接的地方。

 3. 合并短的请求。根据 CPU 的空间局部性原理，对于相近的数据， CPU会一起提取到内存中。另外，合并请求也可以有效减少连接的次数。

 4. 合理拆分多个表 join 的 SQL ，若是超过三个表则禁止 join 。如果表结构建得不合理，应用逻辑处理不当，业务模型抽象有问题，那么三表 join 的数据量由于笛卡儿积操作会呈几何级数增加，所以不推荐这样的做法。另外，对于需要join 的字段，数据类型应保持绝对一致。多表关联查询时，应确保被关联的字段要有索引。

 5. 使用临时表。在不断的嵌套查询中，已经无法很好地利用现有的索引提升查询效率，所以把中间结果保存到临时表，然后重建索引，再通过临时表进行后续的数据操作。

 6. 应用层优化。

 7. 改用其他数据库。[NoSQL数据库探讨](https://blog.csdn.net/hguisu/article/details/5748732)

#### 信息安全

现代黑客攻击的特点是分布式、高流量、深度匿名。黑客的攻击手段十分多样，大体可分为非破坏性攻击和破坏性攻击。非破坏性攻击－般是为了扰乱系统的运行，使之暂时失去正常对外提供服务的能力，比如 DDoS 攻击等。破坏性攻击主要会造成两种后果：系统数据受损或者信息被窃取，比如 CSRF 攻击等。黑客使用的攻击手段有病毒式、洪水式、系统漏洞式等。
现今云端提供商的优势在于能提供套完整的安全解决方案。离开云端提供商 ，一个小企业要从头到尾地搭建一套安全防御体系，技术成本和资源成本将是难以承受的。所以互联网企业都要建立一套完整的信息安全体系，遵循 CIA 原则 即保密性（ Confidentiality ) ，完整性（ Integrity )，可用性（ Availability ）。
- 保密性。 对需要保护的数据（比如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。在实际编程中，通常使用加密等手段保证数据的安全。
- 完整性。访问的数据需要是完整的，而不是缺失的或者被篡改的 不然用户访问的数据就是不正确的。在实际编写代码中，一定要保证数据的完整性，通常的做法是对数据进行签名和校验（比如 MD5和数字签名等）。
- 可用性。 服务需要是可用的。如果连服务都不可用，也就没有安全这一说了。对于这种情况通常使用访问控制、限流等手段解决。
以上三点是安全中最基本的三个要素，后面谈到的 Web 安全问题，都是围绕这三点来展开的。

p46