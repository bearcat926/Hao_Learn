# 2019.8.2

## Header中Content-Disposition的作用与使用方法

`Content-disposition`是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。`Content-disposition`其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。
 **格式说明：** 

> content-disposition = "Content-Disposition" ":" disposition-type *( ";" disposition-parm ) 　

**字段说明：**

`Content-Disposition`为属性名`disposition-type`是以什么方式下载，如`attachment`为以附件方式下载`disposition-parm`为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示，如果需要提示用户保存，就要利用`Content-Disposition`进行一下处理，关键在于一定要加上`attachment`：复制代码 代码如下:

```
Response.AppendHeader("Content-Disposition","attachment;filename=FileName.txt");
```

备注：这样浏览器会提示保存还是打开，即使选择打开，也会使用相关联的程序比如记事本打开，而不是IE直接打开了。`Content-Disposition`就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名。
 **那么由上可知具体的例子：** `Content-Disposition: attachment; filename="filename.xls"`当然`filename`参数可以包含路径信息，但`User-Agnet`会忽略掉这些信息，只会把路径信息的最后一部分做为文件名。
 当你在响应类型为`application/octet- stream`情况下使用了这个头信息的话，那就意味着你不想直接显示内容，而是弹出一个"文件下载"的对话框，接下来就是由你来决定"打开"还是"保存" 了。

**注意事项：**
当代码里面使用`Content-Disposition`来确保浏览器弹出下载对话框的时候。 `

 ```Java
 response.addHeader("Content-Disposition","attachment");
 ```

一定要确保没有做过关于禁止浏览器缓存的操作。
 代码如下:

 ```Java
 response.setHeader("Pragma", "No-cache");
 response.setHeader("Cache-Control", "No-cache");
 response.setDateHeader("Expires", 0);
 ```
 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行。



## springboot打成jar后获取classpath下文件失败

使用如下代码：

```
ClassPathResource resource = new ClassPathResource("application.yml");
File file = resource.getFile();
FileUtils.readLines(file).forEach(System.out::println);
```

未打包时可以获取到文件，打包后报错
```
Caused by: java.io.FileNotFoundException: class path resource [application.yml] cannot be resolved to absolute file path because it does not reside in the file system:jar:file:/D:/sunmnet/JetBrains/workspace/bigdata-parse-table/target/bigdata-parse-table-1.0-SNAPSHOT.jar!/BOOT-INF/classes!/application.yml
        at org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:215) ~[spring-core-4.3.12.RELEASE.jar!/:4.3.12.RELEASE]
        at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:53) ~[spring-core-4.3.12.RELEASE.jar!/:4.3.12.RELEASE]
        at hello.whz.Application.lambda$lookup$0(Application.java:30) [classes!/:1.0-SNAPSHOT]
        at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:732) [spring-boot-1.5.8.RELEASE.jar!/:1.5.8.RELEASE]
        ... 14 common frames omitted
```
这是因为打包后Spring试图访问文件系统路径，但无法访问JAR中的路径。 
因此必须使用`resource.getInputStream()`

```
ClassPathResource resource = new ClassPathResource("application.yml");
InputStream inputStream = resource.getInputStream();
IOUtils.readLines(inputStream).forEach(System.out::println);
```

## Java之泛型 T与T的用法

> `<T> T`表示返回值是一个泛型，传递啥，就返回啥类型的数据，而单独的`T`就是表示限制你传递的参数类型，这个案例中，通过一个泛型的返回方式，获取每一个集合中的第一个数据， 通过返回值`<T> T` 和`T`的两种方法实现

#### `<T> T` 用法

这个`<T> T `表示的是返回值**T**是泛型，**T**是一个占位符，用来告诉编译器，这个东西先给我留着，等我编译的时候，告诉你。

```java
import java.util.ArrayList;
import java.util.List;

/**
 * Created by haohao on 2019-8-2.
 */

public class Demo {

    public static void main(String[] args) {
        Demo demo = new Demo();

        //获取string类型
        List<String> array = new ArrayList<String>();
        array.add("test");
        array.add("doub");
        String str = demo.getListFisrt(array);
        System.out.println(str.getClass().toString());

        //获取nums类型
        List<Integer> nums = new ArrayList<Integer>();
        nums.add(12);
        nums.add(13);

        Integer num = demo.getListFisrt(nums);
        System.out.println(num.getClass().toString());
    }

    /**
     * 这个<T> T 可以传入任何类型的List
     * 参数T
     *     第一个 表示是泛型
     *     第二个 表示返回的是T类型的数据
     *     第三个 限制参数类型为T
     * @param data
     * @return
     */
    private <T> T getListFisrt(List<T> data) {
        if (data == null || data.size() == 0) {
            return null;
        }
        return data.get(0);
    }

}
```

#### T 用法

返回值，直接写**T**表示限制参数的类型，这种方法一般多用于共同操作一个类对象，然后获取里面的集合信息啥的。

```Java
import java.util.ArrayList;
import java.util.List;

/**
 * Created by haohao on 2019-8-2.
 */

public class Demo2<T> {

    public static void main(String[] args) {

        //限制T 为String 类型
        Demo2<String> demo = new Demo2<String>();

        //获取string类型
        List<String> array = new ArrayList<String>();
        array.add("test");
        array.add("doub");
        String str = demo.getListFisrt(array);
        System.out.println(str.getClass().toString());

        //获取Integer类型 T 为Integer类型
        Demo2<Integer> demo2 = new Demo2<Integer>();
        List<Integer> nums = new ArrayList<Integer>();
        nums.add(12);
        nums.add(13);
        Integer num = demo2.getListFisrt(nums);
        System.out.println(num.getClass().toString());
    }

    /**
     * 这个只能传递T类型的数据
     * 返回值 就是Demo<T> 实例化传递的对象类型
     * @param data
     * @return
     */
    private T getListFisrt(List<T> data) {
        if (data == null || data.size() == 0) {
            return null;
        }
        return data.get(0);
    }
}

```

## Java动态代理

说到动态代理，顾名思义就是动态的代理(真是废话)。

#### 关于代理

GOF的23种设计模式之一(结构型模式)。

为其它对象提供一种代理以控制对这个对象的访问。

在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

为了提供额外的处理或者不同的操作而在实际对象与调用者之间插入一个代理对象，这些额外的操作通常需要与实际对象进行通信。

**程序实现：**

抽象类，提供代理对象和真实对象的共用接口，使得任何使用真实对象的地方都能使用代理对象：

```Java
public abstract class Subject {  
    public abstract void request();  
}  
```

真实对象，继承抽象类：

```Java
public class RealSubject extends Subject{  
    @Override  
    public void request() {  
        System.out.println("handle real subject request...");  
    }  
} 
```

代理对象，同样继承抽象类：

```Java
public class Proxy extends Subject{  
    private RealSubject realSubject;  
      
    public Proxy(RealSubject real){  
        this.realSubject=real;  
    }  
    @Override  
    public void request() {  
        if(realSubject==null){  
            realSubject=new RealSubject();  
        }  
        System.out.println("before real subject request.");//请求前处理逻辑.  
        realSubject.request();  
        System.out.println("after real subject request.");//请求后处理逻辑.  
    }  
}  
```

程序入口：

```Java
public static void main(String[] args) {  
        Proxy proxy=new Proxy(new RealSubject());  
        proxy.request();  
}  
```

举例：权限代理(权限访问控制)、远程访问代理等。

#### 什么是动态代理

说起动态，其实不如先说什么是静态。所谓静态代理，个人理解为自己手写的代理类，或者用工具生成的代理类，或者别人帮你写的代理类(没说一样...)。总之，就是程序运行前就已经存在的编译好的代理类。

相反，如果代理类程序运行前并不存在，需要在程序运行时动态生成(无需手工编写代理类源码)，那就是今天要说的动态代理了。

如何生成的：根据Java的反射机制动态生成。

**程序实现：**

目标接口TargetInterface：

```Java
public interface TargetInterface {  
    public int targetMethodA(int number);  
    public int targetMethodB(int number);  
} 
```

很简单，一个普通的接口，里面有若干方法(此处写2个示范一下)

实现该接口的委托类ConcreteClass：

```Java
public class ConcreteClass implements TargetInterface{  
  
    public int targetMethodA(int number) {  
        System.out.println("开始调用目标类的方法targetMethodA...");  
        System.out.println("操作-打印数字:"+number);  
        System.out.println("结束调用目标类的方法targetMethodA...");  
        return number;  
    }  
      
    public int targetMethodB(int number){  
        System.out.println("开始调用目标类的方法targetMethodB...");  
        System.out.println("操作-打印数字:"+number);  
        System.out.println("结束调用目标类的方法targetMethodB...");  
        return number;  
    }  
  
} 
```

很简单，一个普通的类，实现了目标接口。

代理处理器类ProxyHandler：

```java
public class ProxyHandler implements InvocationHandler{  
    private Object concreteClass;  
      
    public ProxyHandler(Object concreteClass){  
        this.concreteClass=concreteClass;  
    }  
  
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
        System.out.println("proxy:"+proxy.getClass().getName());  
        System.out.println("method:"+method.getName());  
        System.out.println("args:"+args[0].getClass().getName());  
          
        System.out.println("Before invoke method...");  
        Object object=method.invoke(concreteClass, args);//普通的Java反射代码,通过反射执行某个类的某个方法  
        //System.out.println(((ConcreteClass)concreteClass).targetMethod(10)+(Integer)args[0]);  
        System.out.println("After invoke method...");  
        return object;  
    }  
  
} 
```

该类实现了Java反射包中的InvocationHandler接口。代理实例调用方法时，将对方法调用指派到它的代理处理器程序的invoke方法中。invoke方法内部实现预处理，对委托类方法调用，事后处理等逻辑。

最后是入口程序：

```java
public class DynamicProxyExample {  
    public static void main(String[] args){  
         ConcreteClass c=new ConcreteClass();//元对象(被代理对象)  
         InvocationHandler ih=new ProxyHandler(c);//代理实例的调用处理程序。  
         //创建一个实现业务接口的代理类,用于访问业务类(见代理模式)。  
         //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序，如ProxyHandler。  
         TargetInterface targetInterface=  (TargetInterface)Proxy.newProxyInstance(c.getClass().getClassLoader(),c.getClass().getInterfaces(),ih);  
         //调用代理类方法,Java执行InvocationHandler接口的方法.  
         int i=targetInterface.targetMethodA(5);  
         System.out.println(i);  
         System.out.println();  
         int j=targetInterface.targetMethodB(15);  
         System.out.println(j);  
    }  
} 
```

首先创建委托类对象，将其以构造函数传入代理处理器，代理处理器ProxyHandler中会以Java反射方式调用该委托类对应的方法。然后使用Java反射机制中的Proxy.newProxyInstance方式创建一个代理类实例，创建该实例需要指定该实例的类加载器，需要实现的接口(即目标接口)，以及处理代理实例接口调用的处理器。

最后，调用代理类目标接口方法时，会自动将其转发到代理处理器中的invoke方法内，invoke方法内部实现预处理，对委托类方法调用，事后处理等逻辑。

#### 使用Java动态代理机制的好处

1. 减少编程的工作量：假如需要实现多种代理处理逻辑，只要写多个代理处理器就可以了，无需每种方式都写一个代理类。

2. 系统扩展性和维护性增强，程序修改起来也方便多了(一般只要改代理处理器类就行了)。

#### 使用Java动态代理机制的限制

目前根据GOF的代理模式，代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，目前无法使用该机制。有人说这不是废话吗，本来Proxy模式定义的就是委托类要实现接口的啊！但是没有实现接口的类，该如何实现动态代理呢？

当然不是没有办法，这也是我后面抽时间要继续整理和总结原先使用过的一件神器，那就是大名鼎鼎的CGLib。

## **CGLIB**

#### CGLIB介绍与原理

**一、什么是CGLIB?**

CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。

**二、CGLIB原理**

CGLIB原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。

CGLIB底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。

**CGLIB缺点**：对于final方法，无法进行代理。

**三、CGLIB的应用**

广泛的被许多AOP的框架使用，例如Spring AOP和dynaop。Hibernate使用CGLIB来代理单端single-ended(多对一和一对一)关联。

**四、CGLIB的API**

1. Jar包：

cglib-nodep-xxx.jar：使用nodep包不需要关联asm的jar包,jar包内部包含asm的类.

cglib-xxx.jar：使用此jar包需要关联asm的jar包,否则运行时报错.

2. CGLIB类库：

**由于基本代码很少，学起来有一定的困难，主要是缺少文档和示例，这也是CGLIB的一个不足之处。**

本系列使用的CGLIB版本是**2.2**。

net.sf.cglib.core:底层字节码处理类，他们大部分与ASM有关系。

net.sf.cglib.transform:编译期或运行期类和类文件的转换

net.sf.cglib.proxy:实现创建代理和方法拦截器的类

net.sf.cglib.reflect:实现快速反射和C#风格代理的类

net.sf.cglib.util:集合排序等工具类

net.sf.cglib.beans:JavaBean相关的工具类

**本实战系列主要涉及的包**：net.sf.cglib.proxy、net.sf.cglib.reflect、net.sf.cglib.util、net.sf.cglib.beans

#### 通过MethodInterceptor和Enhancer实现CGLib动态代理

1. 被代理类：

首先，定义一个类，该类没有实现任何接口，包含两个方法。

```java
public class ConcreteClassNoInterface {  
    public String getConcreteMethodA(String str){  
        System.out.println("ConcreteMethod A ... "+str);  
        return str;  
    }  
    public int getConcreteMethodB(int n){  
        System.out.println("ConcreteMethod B ... "+n);  
        return n+10;  
    }  
}  
```

2. 拦截器：

定义一个拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。

```java
public class ConcreteClassInterceptor implements MethodInterceptor{  
    public Object intercept(Object obj, Method method, Object[] arg, MethodProxy proxy) throws Throwable {  
        System.out.println("Before:"+method);    
        Object object=proxy.invokeSuper(obj, arg);  
        System.out.println("After:"+method);   
        return object;  
    }  
}  
```

参数：Object为由CGLib动态生成的代理类实例，Method为上文中实体类所调用的被代理的方法引用，Object[]为参数值列表，MethodProxy为生成的代理类对方法的代理引用。

返回：从代理实例的方法调用返回的值。

其中，proxy.invokeSuper(obj,arg)：

调用代理类实例上的proxy方法的父类方法（即实体类ConcreteClassNoInterface中对应的方法）

在这个示例中，只在调用被代理类方法前后各打印了一句话，当然实际编程中可以是其它复杂逻辑。

3. 生成动态代理类：

```java
Enhancer enhancer=new Enhancer();
enhancer.setSuperclass(ConcreteClassNoInterface.class);
enhancer.setCallback(new ConcreteClassInterceptor());
ConcreteClassNoInterface ccni=(ConcreteClassNoInterface)enhancer.create();
ccni.getConcreteMethodA("hao hao");
ccni.getConcreteMethodB(0); 
```

这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展。

首先将被代理类ConcreteClassNoInterface设置成父类，然后设置拦截器ConcreteClassInterceptor，最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型ConcreteClassNoInterface。最后，在代理类上调用方法。

查看控制台输出：

```
Before:public java.lang.String cn.hutool.aop.test.ConcreteClassNoInterface.getConcreteMethodA(java.lang.String)
ConcreteMethod A ... hao hao
After:public java.lang.String cn.hutool.aop.test.ConcreteClassNoInterface.getConcreteMethodA(java.lang.String)
Before:public int cn.hutool.aop.test.ConcreteClassNoInterface.getConcreteMethodB(int)
ConcreteMethod B ... 0
After:public int cn.hutool.aop.test.ConcreteClassNoInterface.getConcreteMethodB(int)
```

可以看到，拦截器在调用被代理类方法前后都执行了print操作。

#### 回调过滤器CallbackFilter

**一、作用**

在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。

在JDK动态代理中并没有类似的功能，对InvocationHandler接口方法的调用对代理类内的所以方法都有效。

**二、程序实现**：

首先定义一个被代理类，包含3个方法：

```Java
public class ConcreteClassCallbackFilterNoInterface {  
    public String getConcreteMethodA(String str){  
        System.out.println("ConcreteMethod A ... "+str);  
        return str;  
    }  
    public int getConcreteMethodB(int n){  
        System.out.println("ConcreteMethod B ... "+n);  
        return n+10;  
    }  
    public int getConcreteMethodFixedValue(int n){  
        System.out.println("getConcreteMethodFixedValue..."+n);  
        return n+10;  
    }  
}  
```

其次，定义实现过滤器CallbackFilter接口的类：

```Java
public class ConcreteClassCallbackFilter implements CallbackFilter{  
    public int accept(Method method) {  
        if("getConcreteMethodB".equals(method.getName())){  
            return 0;//Callback callbacks[0]  
        }else if("getConcreteMethodA".equals(method.getName())){  
            return 1;//Callback callbacks[1]  
        }else if("getConcreteMethodFixedValue".equals(method.getName())){  
            return 2;//Callback callbacks[2]  
        }  
        return 1;  
    }  
} 
```

其中return值为被代理类的各个方法在回调数组Callback[]中的位置索引（见下文）。

**生成代理类**：

```java
Enhancer enhancer=new Enhancer();
enhancer.setSuperclass(ConcreteClassCallbackFilterNoInterface.class);
CallbackFilter filter=new ConcreteClassCallbackFilter();
enhancer.setCallbackFilter(filter);

Callback interceptor=new ConcreteClassInterceptor();//(1)
Callback noOp= NoOp.INSTANCE;//(2)
Callback fixedValue=new ConcreteClassFixedValue();//(3)
Callback[] callbacks=new Callback[]{interceptor,noOp,fixedValue};

enhancer.setCallbacks(callbacks);
ConcreteClassCallbackFilterNoInterface proxyObject=(ConcreteClassCallbackFilterNoInterface)enhancer.create();
//...见下文
```

生成代理类前，设置了CallbackFilter，上文中ConcreteClassCallbackFilter实现类的返回值对应Callback[]数组中的位置索引。此处包含了CGLib中的3种回调方式：

**(1)MethodInterceptor**：方法拦截器，上一篇文章中已经详细介绍过，此处不再赘述。

**(2)NoOp.INSTANCE**：这个NoOp表示no operator，即什么操作也不做，代理类直接调用被代理的方法不进行拦截。

**(3)FixedValue**：表示锁定方法返回值，无论被代理类的方法返回什么值，回调方法都返回固定值。

其中，ConcreteClassFixedValue类实现如下：

```java
public class ConcreteClassFixedValue implements FixedValue{  
    public Object loadObject() throws Exception {  
        System.out.println("ConcreteClassFixedValue loadObject ...");  
        Object object=999;  
        return object;  
    }  
} 
```

该类实现FixedValue接口，同时锁定回调值为999(整型，CallbackFilter中定义的使用FixedValue型回调的方法为getConcreteMethodFixedValue，该方法返回值为整型)。

**下面进行验证**：

```java
//接上文...  
System.out.println("*** NoOp Callback ***");  
proxyObject.getConcreteMethodA("abcde");  
  
System.out.println("*** MethodInterceptor Callback ***");  
proxyObject.getConcreteMethodB(1);  
  
System.out.println("*** FixedValue Callback ***");  
int fixed1=proxyObject.getConcreteMethodFixedValue(128);  
System.out.println("fixedValue1:"+fixed1);  
int fixed2=proxyObject.getConcreteMethodFixedValue(256);  
System.out.println("fixedValue2:"+fixed2);  
```

**控制台输出**：

```
Connected to the target VM, address: '127.0.0.1:2780', transport: 'socket'
*** NoOp Callback ***
ConcreteMethod A ... abcde
*** MethodInterceptor Callback ***
Before:public int cn.hutool.aop.test.ConcreteClassCallbackFilterNoInterface.getConcreteMethodB(int)
ConcreteMethod B ... 1
After:public int cn.hutool.aop.test.ConcreteClassCallbackFilterNoInterface.getConcreteMethodB(int)
*** FixedValue Callback ***
ConcreteClassFixedValue loadObject ...
fixedValue1:999
ConcreteClassFixedValue loadObject ...
fixedValue2:999
Disconnected from the target VM, address: '127.0.0.1:2780', transport: 'socket'
```

getConcreteMethodA对应CallbackFilter中定义的索引1，在Callback[]数组中使用的过滤为NoOp,因此直接执行了被代理方法。

getConcreteMethodB对应CallbackFilter中定义的索引0，在Callback[]数组中使用的过滤为MethodInterceptor，因此执行了方法拦截器进行拦截。

getConcreteMethodFixedValue对应CallbackFilter中定义的索引2，在Callback[]数组中使用的过滤为FixedValue，因此2次赋值128和256的调用其结果均被锁定为返回999。

