

# 第一章 计算机基础

## 1.1 走进0与1的世界

#### 为何负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32 位）和长整型（64 位）数上，假如在整型数上移动的位数是32 位，**无论是否带符号位以及移动方向，均为本身**。因为移动的位数是个mod 32 的结果，即 `35 >> 1` 与 `35 >> 33` 是一样的结果。如果是长整型， mod 64，即 `35 << 1` 与`35 << 65`的结果是一样的。负数在无符号往右移动 63 位时，除最右边为1， 左边均为0，达到最小值1，如果 >>> 64，则为其原数值本身。

```java
public class Test{

	public static void main(String[] args) {
		int a = 35;
		int b = -35;

		System.out.println("==========正数============");
		System.out.println(a >>> 1);

		System.out.println(a >>> 27);
		System.out.println(a >>> 28);
		System.out.println(a >>> 29);
		System.out.println(a >>> 30);
		System.out.println(a >>> 31);
		System.out.println(a >>> 32);
		System.out.println(a >>> 33);
		System.out.println("==========负数============");
		System.out.println(b >>> 1);

		System.out.println(b >>> 27);
		System.out.println(b >>> 28);
		System.out.println(b >>> 29);
		System.out.println(b >>> 30);
		System.out.println(b >>> 31);
		System.out.println(b >>> 32);
		System.out.println(b >>> 33);
	}
	
}
```

结果：

```
==========正数============
17	//1
0	//27
0
0
0
0	//31
35	//32
17
==========负数============
2147483630	//1
31	//27
15
7
3
1	//31
-35	//32
2147483630
```

#### 异或运算 ^

异或运算没有短路功能，一般在哈希算法中用于离散哈希值，对应的位上不一样才是1。



## 1.2 浮点数

#### 浮点数表示

当前业界流行的浮点数标准是 `IEEE754` ，该标准规定了4种浮点数类型：单精度、双精度、延伸单精度、延伸双精度。前两种类型是最常用的。

**浮点数无法表示零值。**

范围：

| 精度       | 字节数 | 正数取值范围             | 负数取值范围             |
| ---------- | ------ | ------------------------ | ------------------------ |
| 单精度类型 | 4      | `1.4e-45 至 3.4e+38`     | `-3.4e+38 至 -1.4e-45`   |
| 双精度类型 | 8      | `4.9e-324 至 1.798e+308` | `1.798e+308 至 4.9e-324` |

#### 阶码位

IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。

移码是将一个真值在数轴上正向平移一个偏移量之后得到的，即 [x]~移~ = x + 2^n-1^ （n为x的二进制位数，含符号位）。移码的几何意义是把真值映射到一个正数域，其特点是可以直观地反映两个真值的大小，即移码大的真值也大。

> 真值 = 阶码 - （2^n-1^ - 1）

#### 为什么偏移值为2^n-1^ - 1 而不是 2^n-1 呢？

因为8个二进制位能表示指数的取值范围为 [-128,127] ，现在将指数变成移码表示，即将区间 [-128,127] 正向平移到正数域，区间里的每个数都需要加上 128 ，从而得到阶码范围为[0,255 ] 。

由于计算机规定阶码全为 0 或全为 1 两种情况被当作特殊值处理（全 0 被认为是机器零，全 1 被认为是无穷大），去除这两个特殊值，阶码的取值范围变成了 [1,254] 。

如果偏移量不变仍为128 的话，则根据换算关系公式 [x]~阶~ = x + 128 得到指数的范围变成[-127,126]，指数最大只能取到 126 ，显然会缩小浮点数能表示的取值范围。

所以 IEEE754 标准规定单精度的阶码偏移量为 2^n-1^ - 1 （即 127 ），这样能表示的指数范围为[-126,127]，指数最大值能取到 127。

0**111-1111-0**111-1111-1111-1111-1111-1111

为了节约存储空间，将符合规格化位数的首个1省略，所以尾数表面上是23位，却表示了24位二进制数。

#### 加减运算
对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。

1. 零值检测。 
	检查参加运算的两个数中是否存在为 0 的数（ 0  在浮点数是一
种规定，即阶码与尾数全为 0 ），因为浮点数运算过程比较复杂，如果其中一个数为 0,可以直接得出结果。
2. 对阶操作。 
	通过比较阶码的大小判断小数点位置是否对齐。IEEE754 规定对阶的移动方向为向右移动，即选择阶码小的数进行操作。
3. 尾数求和。
4. 结果规格化。
	如果运算的结果仍然满足规格化形式，则无须处理，否则需要通过尾数位的向左或右移动调整达到规格化形式。尾数位向右移动称为右规，反之称为左规。
5. 结果舍入。
	在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃， 从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。

#### 浮点数使用
在使用浮点数时推荐使用**双精度**，使用单精度由于表示区间的限制 ，计算结果会出现微小的误差。
1. 在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储。
2. 在要求精确表示小数点 n 位的业务场景下，比如圆周率要求存储小数点后 1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推荐采用数组保存小数部分的数据。
3. 在比较浮点数时，由于存在误差，往往会出现意料之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。
4. 在数据库中保存小数时，推荐使用 `decimal` 类型，禁止使用 float 类型和 double 类型。因为这两种类型在存储的时候，存在精度损失的问题。

## 1.3 字符集与乱码
实现 Unicode 的编码格式有三种 UTF-8 UTF-16 UTF-32，UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为对Unicode 的压缩方式。根据二八原则，常用文字只占文字总数的 20% 左右。

在日常开发中，字符集如果不兼容则会造成乱码。

乱码的出现场景并不止于编码环境中，还有网页展示、文本转换、文件读取等。数据流从底层数据库到应用层，到Web 服务器，再到客户端显示，每位开发工程师都会碰到字符乱码的问题，排查起来是一个比较长的链路。

数据库是存储字符之源，在不同层次上都能够设置独立的字符集，如服务器级别、 schema 级别、表级别甚至列级别。为了减少麻烦，所有情况下的字符集设置最好是一致的。

## 1.4 CPU与内存
越往 CPU 核心靠近，存储越贵，速度越快。越往下，存储越便宜、速度越慢，当然容量也会更大。
程序员们最害怕的 OOM（Out Of Memory）通常来源于由于不恰当的编码方式而导致内存的资源耗尽 ，虽然现代内存的容量已经今非昔比，但仍然是可以在秒级内耗尽所有内存资源的。
内存的抽象就是线性空间内的字节数组，通过下标访问某个特定位置的数据，比如 C 语言使用 malloc（） 进行内存的分配，然后使用指针进行内存的读与写；而以 Java 为代表的编程语言，内存就交给 JVM 进行自动分配与释放，这个过程
称为垃圾回收机制。虽然垃圾回收机制能为程序员减负，但如果不加节制的话，同样会耗尽内存资源。

## 1.5 TCP / IP

#### 概述
TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协议／因特网互联协议，这个大家族里的其他知名协议还有 HTTP, HTTPS、 FTP、SMTP、UDP、 ARP、PPP、IEEE 802.x 等。它是当前流行的网络传输协议框架，从严格意义上讲它是一个协议族，因为 TCP、IP 是其中最为核心的协议，所以就把该协议族称为 TCP/IP 。
而另一个是耳熟能详的 ISO/OSI 的七层传输协议，其中 OSI( Open System Interconnection ）的出发点是想设计出计算机世界通用的网络通信基本框架，它已经被淘汰。
![1565492275741](E:\git_repo\Hao_Learn\2019\8\img\1565492275741.png)


- 链路层：单个0、1 是没有意义的，链路层以字节为单位把 0 与 1 进行分组，  定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。
![1565492513881](E:\git_repo\Hao_Learn\2019\8\img\1565492513881.png)
MAC 地址长 6个字节共 48 位，通常使用十六进制数表示。使用 ifconfig -a 命令即可看到 MAC 地址。MAC地址的前 24 位（3个字节）由管理机构统一分配，后24 位由厂商自己分配，保证网卡全球唯一。

- 网络层： 根据 IP 定义网络地址，区分网段。子网内根据ARP（Address Resolution Protocol，地址解析协议）进行 MAC 寻址，子网外进行路由转发数据包，这个数据包即 IP 数据包。
- 传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是 UDP和TCP。UDP 只是在 IP 数据包上增加端口等部分信息，是面向无连接的，是不可靠传输，多用于视频通信、电话会议等（即使少一帧数据也无妨）。与之相反的TCP 是面向连接的。所谓面向连接，是一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一条固定的通路承载着数据的可靠传输。
- 应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数
据。比如，E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是都能够读取邮件内容，是因为 SMTP （Simple Mail Transfer Protocol，简单邮件传输协议）就像传统的书信恪式一样，按规定填写邮编及收信人信息。

总结一下，程序在发送消息时，应用层按既定的协议打包数据，随后由传输层加
上双方的端口号 ，由网络层加上双方的 IP 地址，由链路层加上双方的 MAC 地址，并将数据拆分成数据帧，经过多个路由器和网关后，到达目标机器。简而言之，就是按**端口 -> IP 地址 -> MAC 地址 **这样的路径进行数据的封装和发送，解包的时候反过来操作即可

#### IP 协议

IP 是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP
首先规定出 IP 地址格式，该地址相当于在逻辑意义上进行了网段的划分，给每台计算机额外设置了一个唯一的详细地址。
IP 地址属于网络层，主要功能在 WLAN 内进行路由寻址，选择最佳路由。
![1565493293196](E:\git_repo\Hao_Learn\2019\8\img\1565493293196.png)
生存时间TTL（Time To Live），即数据包的生存时间 ，它是数据包可经过的最多路由器总数。TTL 初始值由源主机设置后，数据包在传输过程中每经过一个路由器，TTL 值则减 1 ，当该字段为 0 时，数据包被丢弃，并发送 ICMP 报文通知源主机，以防止源主机无休止地发送报文。这里扩展说一下 ICMP ( Internet Control Message Protocol，Internet控制报文协议 ），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。 ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重要，经常使用的 ping、tracert 命令就是基于 ICMP 检测网络状态的有力工具。

这里说明一下tracert命令，也被称为Windows路由跟踪实用程序，在cmd中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。

从左到右的5条信息分别代表了“生存时间”（每途经一个路由器结点自增1）、“三次发送的ICMP包返回时间”（共计3个，单位为毫秒ms）和“途经路由器的IP地址”（如果有主机名，还会包含主机名）。其中带有星号（*）的信息表示该次ICMP包返回时间超时。

如果在“tracert”命令后添加一个不存在的IP地址，tracert程序则会报错。

![1565493998028](E:\git_repo\Hao_Learn\2019\8\img\1565493998028.png)

IP 报文在互联网上传输时，可能要经历多个物理网络，才能从源主机到达目标主机。比如在手机上给某个 PC 端的朋友发送一个信息，经过无线网的 IEEE 802.1x 认证，转到光纤通信上，然后进入内部企业网 802.3 ，并最终到达目标 PC。由于不同硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度被称为最大传输单元，即 MTU ( Maximum Transmission Unit ）。那么在不同的物理网之间就可能需要对 IP 报文进行分片，这个工作通常由路由器负责完成。
IP是TCP／IP的基石，几平所有其他协议都建立在 IP 所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的 TCP。

#### 既然链路层可以通过唯一的 MAC 地址找到机器，为什么还需要通过唯一的 IP 地址再来标识呢？

简单地说，在世界范围内，不可能通过广播的方式，从数以千万计的计算机里找到目标 MAC 地址的计算机而不超时。在数据投递时就需要对地址进行分层管理。

#### TCP建立连接
TCP（Transmission Control Protocol,  传输控制协议），是一种面向连接、确保数据在端到端间可靠传输的协议。面向连接是插在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形。每个 TCP 数据包是封装在 IP 包中的，每个 IP头的后面紧接着的是 TCP 头。
![1565535187390](E:\git_repo\Hao_Learn\2019\8\img\1565535187390.png)

协议第一行的两个端口号各占两个字节，分别表示了源机器和目标机器的端口号。这两个端口号与 IP 报头中的源 IP 地址和目标 IP 地址所组成的四元组可唯一标识一条TCP 连接。由于 TCP 是面向连接的 ，因此有服务端和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的建立连接请求。当客户端发起第一个请求建立连接的 TCP 包时，目标机器端口就是服务端所监听的端口号。比如一些由国际组织定义的广为人知端口号一一代表 HTTP 服务的 80 端口、代表 SSH 服务的22 端口、代表 HTTPS 服务的 443 端口。可通过 netstat 命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。

![1565535499323](E:\git_repo\Hao_Learn\2019\8\img\1565535499323.png)

协议第二行和第二行是序列号，各占 4 个字节。前者是指所发送数据包中数据部
分第一个字节的序号，后者是指期望收到来自对方的下一个数据包中数据部分第一个字节的序号。

由于 TCP 报头中存在一些扩展字段，所以需要通过长度为 4 个 bit 的头部长度字段表示 TCP 报头的大小，这样接收方才能准确地计算出包中数据部分的开始位置。

TCP 的 FLAG 位由 6 个 bit 组成，分别代表 ACK、SYN、FIN、 URG、PSH、RST ，都以置1 表示有效。SYN ( Synchronize Sequence Numbers ）用作建立连接时的同步信号；ACK ( Acknowledgement ）用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN ( Finish ）表示后面没有数据需要发送，通常意昧着所建立的连接需要关闭了。
URG（紧急位）：设置为1时，首部中的紧急指针有效。PSH（推位）：当设置为1时，要求把数据尽快的交给应用层，不做处理，通常的数据中都会带有PSH，但URG只在紧急数据的时设置，也称“带外数据“；RST表示复位，用来异常的关闭连接。在发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。
![1565717495945](E:\git_repo\Hao_Learn\2019\8\img\1565717495945.png)

三次握手有两个主要目的：信息对等和防止超时。先从信息对等角度来看，双方只有确定4 类信息（自己/对方的发报/收报能力），才能建立连接。再者是防止出现请求超时导致脏连接。 TTL 网络报文的生存时间往往都会超过 TCP 请求超时时间，如果两次握手就可以创建连接，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B机器会以为是A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据，以致最后只是 B 机器单方面创建连接完毕。

![1565717542453](E:\git_repo\Hao_Learn\2019\8\img\1565717542453.png)

从编程的角度， TCP 连接的建立是通过文件描述待（ File Descriptor ，fd） 完成的。通过创建套接字获得一个 fd，然后服务端和客户端需要基于所获得的 fd调用不同的函数分别进入监听状态和发起连接请求。由于 fd 的数量将决定服务端进程所能建立连接的数量 ，对于大规模分布式服务来说，当 fd 不足时就会出现 `open too many files` 错误而使得无法建立更多的连接。为此，需要注意调整服务端进程和操作系统所支持的最大文件句柄数。通过使用 `ulimit -n` 命令来查看单个进程可以打开文件句柄的数量。如果想查看当前系统各个进程产生了多少句柄，可以使用如下的命令：
>lsof -n | awk '{print $2}' | sort|uniq -c |sort -nr|more

![1565718109948](E:\git_repo\Hao_Learn\2019\8\img\1565718109948.png)
左侧列是句柄数，右侧列是进程号。
`lsof` 命令用于查看当前系统所打开 fd 的数量。在 Linux 系统中，很多资源都是以 fd 的形式进行读写的，除了提到的文件和 TCP 连接 UDP 数据报、输入输出设备等都被抽象成了 fd。

TCP 在协议层面支持 Keep Alive 功能，即隔段时间通过向对方发送数据表示连接处于健康状态。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳包检查连接的健康度。一旦心跳包出现异常不仅会主动关闭连接，还会回收与连接相关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。

#### TCP断开连接
TCP 是全双工通信，双方都能作为数据的发送方和接收方，但 TCP 连接也会有断开的时候。

![1565718820471](E:\git_repo\Hao_Learn\2019\8\img\1565718820471.png)

图中的红色字体所示的 TIME_WAIT 和 CLOSE_WAIT 分别表示主动关闭和被动关闭产生的阶段性状态，如果在线上服务器大量出现这两种状态，就会加重机器负载，也会影响有效连接的创建，因此需要进行有针对性的调优处理。
• TIME_WAIT：主动要求关闭的机器表示收到了对方的 FIN 报文，并发送出了ACK 报文，进入 TIME_WAIT 状态，等 2MSL 后即可进入到 CLOSED 状态。如果 FIN_WAIT_1 状态下，同时收到带 FIN 标志和 ACK 标志的报文时，可以直接进入 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。
• CLOSE_WAIT： 被动要求关闭的机器收到对方请求关闭连接的 FIN 报文，在第一次 ACK 应答后，马上进入 CLOSE_WAIT 状态。这种状态其实表示在等待关闭，并且通知应用程序发送剩余数据，处理现场信息，关闭相关资源。

在TME_WAIT 等待的 2MSL 是报文在网络上生存的最长时间，超过阈值便将报文丢弃。一般来说， MSL 大于 TTL 衰减至 0 的时间。在RFC793 中规定 MSL 为2 分钟。但是在当前的高速网络中， 2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。既然 TIME_WAIT 貌似是百害而无一利的，为何不直接关闭，进入 CLOSED 状态呢？原因有如下几点。
1. 确认被动关闭方能够顺利进入 CLOSED 状态。
	假如最后一个 ACK 由于网络原因导致无法到达 B 机器，处于 LAST_ACK 机器通常 “自信” 地以为对方没有收到自己的 FIN+ACK 报文，所以会重发。 A 机器收到第二次的 FIN+ACK 报文，会重发一次 ACK ，并且重新计时。
2. 防止失效请求。
	这样做是为了防止己失效连接的请求数据包与正常连接的
请求数据包混淆而发生异常。因为 TIME_WAIT 状态无法真正释放句柄资源，在此期间，Socket 中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高并发服务器来说，会极大地限制有效连接的创建数量，成为性能瓶颈。所以，建议将高并发服务器 TIME_WAIT 超时时间调小。
在服务器上通过变更`/etc/sysctl.conf` 文件来修改该省略值（秒）：`net.ipv4.tcp_fin_timeout = 30` （建议小于 30 秒为宜）。
修改完之后执行`/sbin/sysctl -p` 让参数生效即可。可以通过如下命令：
>netstat -n |awk '/^tcp/	{++S[$NF]}	END	{for(a in S)	print	a,	S[a] }'

查看各连接状态的计数情况，为了使数据快速生效， 2MSL 从 240 秒更改为5 秒。
在`sysctl.conf` 中还有其他连接参数也用来不断地调优服务器 TCP 连接能力，以提升服务器的有效利用率。如何快速地使连接资源被释放和复用，参数的优化往往可以取得事半功倍的效果。

TIME_WAIT 是挥手四次断开连接的尾声，如果此状态连接过多，则可以通过优化服务器参数得到解决。如果不是对方连接的异常，一般不会出现连接无法关闭的情况。但是 CLOSE_WAIT 过多很可能是程序自身的问题，比如在对方关闭连接后，程序没有检测到，或者忘记自己关闭连接。在某次故障中，外部请求出现超时的情况，当时的 Apache 服务器使用的是默认的配置方式，通过命令`netstat -ant|grep -i "443"|grep CLOSE_ WAIT|wc -l`发现在HTTPS 的 443 端口上堆积了 2.1 万个左右的CLOSE_WAIT 状态。经排查发现，原来是某程序处理完业务逻辑之后没有释放流操作，但程序一直运行正常，直到运营活动时才大量触发该业务逻辑，最终导致故障的产生。

#### 连接池
RPC 服务集群的注册中心与服务提供方、消费方之间，消息服务集群的缓存服务器和消费者服务器之间，应用后台服务器和数据库之间，都会使用**连接池**来提升性能。
数据库连接池负责分配、管理和释放连接，这是一种以内存空间换取时间的策略，能够明显地提升数据库操作的性能。但如果数据库连接管理不善，也会影响到整个应用集群的吞吐量。连接池配置错误加上**慢SQL** ，就像屋漏偏逢连夜雨，可以瞬间让一个系统进入服务超时假死宕机状态。

> 导致慢 SQL 的原因：
> 1. SQL编写问题
   >- 与索引相关的规则：
     - 字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；
     - mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；
     - 不要在字段前面加减运算；
     - 字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；
     - like % 在前面用不到索引；
     - 根据联合索引的第二个及以后的字段单独查询用不到索引；
     - 不要使用 select * ；
     - 排序请尽量使用升序 ;
     - or 的查询尽量用 union 代替 （InnoDB）；
     - 复合索引高选择性的字段排在前面；
     - order by / group by 字段包括在索引当中减少排序，效率会更高。
   >- 尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；
   - 分页语句 limit 的问题；
   - 删除表所有记录请用 truncate，不要用 delete；
   - 不让 mysql 干多余的事情，如计算；
   - 输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；
   - 在 Innodb上用 select count( * )，因为 InnoDB 会存储统计信息；
   - 慎用 Order by rand()。
>2. 锁
>3. 业务实例相互干绕对 IO/CPU 资源争用
>4. 服务器硬件
>5. MYSQL BUG
>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的分析诊断工具有：mysql dumpslow ;  mysql profile ;  mysql explain

连接数的创建是受到服务器操作系统的`fd`（文件描述符）数量限制的。创建更多的活跃连接，就需要消耗更多的`fd`，系统默认单个进程可同时拥有 1024 个`fd`，该值虽然可以适当调整，但如果无限制地增加，会导致服务器在`fd`的维护和切换上消耗过多的精力，从而降低应用吞吐量。

在双十一的场景里，应用服务器的全链路上不论是连接池的峰值处理，还是应用之间的调用频率，都会有相关的限流措施和降级预案。

一般可以把连接池的最大连接数设置在 30 个左右 理论上还可以设置更大的值，但是 DBA（Database Adiministrator） 一般不会允许，因为往往只有出现了慢 SQL 才需要使用更多的连接数。这时候通常需要优化应用层逻辑或者创建数据库索引，而不是一昧地采用加大连接数这种治标不治本的做法。极端情况下甚至会导致数据库服务不晌应，进而影响其他业务。

从经验上来看，在数据库层面的请求应答时间必须在100ms 以内，秒级的 SQL查询通常存在巨大的性能提升空间，有如下应对方案：

 1. 建立高效且合适的索引。
 2. 排查连接资源未显式关闭的情形。
	 	要特别注意在 ThreadLocal 或流式计算中使用数据库连接的地方。
 3. 合并短的请求。
	 	根据 CPU 的空间局部性原理，对于相近的数据， CPU会一起提取到内存中。另外，合并请求也可以有效减少连接的次数。
 4. 合理拆分多个表 join 的 SQL ，若是超过三个表则禁止 join 。
	 	如果表结构建得不合理，应用逻辑处理不当，业务模型抽象有问题，那么三表 join 的数据量由于笛卡儿积操作会呈几何级数增加，所以不推荐这样的做法。另外，对于需要join 的字段，数据类型应保持绝对一致。多表关联查询时，应确保被关联的字段要有索引。
 5. 使用临时表。
	 	在不断的嵌套查询中，已经无法很好地利用现有的索引提升查询效率，所以把中间结果保存到临时表，然后重建索引，再通过临时表进行后续的数据操作。
 6. 应用层优化。
 7. 改用其他数据库。因为不同数据库针对的业务场景是不同的。
    [NoSQL数据库探讨](https://blog.csdn.net/hguisu/article/details/5748732)

## 1.6 信息安全

#### 黑害与安全
现代黑客攻击的特点是分布式、高流量、深度匿名。黑客的攻击手段十分多样，大体可分为非破坏性攻击和破坏性攻击。**非破坏性攻击**一般是为了扰乱系统的运行，使之暂时失去正常对外提供服务的能力，比如 DDoS 攻击等。**破坏性攻击**主要会造成两种后果：系统数据受损或者信息被窃取，比如 CSRF 攻击等。黑客使用的攻击手段有病毒式、洪水式、系统漏洞式等。
现今云端提供商的优势在于能提供套完整的安全解决方案。离开云端提供商 ，一个小企业要从头到尾地搭建一套安全防御体系，技术成本和资源成本将是难以承受的。所以互联网企业都要建立一套完整的信息安全体系，遵循 CIA 原则 即保密性（ Confidentiality ) ，完整性（ Integrity )，可用性（ Availability ）：

- 保密性。 对需要保护的数据（比如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。在实际编程中，通常使用加密等手段保证数据的安全。
- 完整性。访问的数据需要是完整的，而不是缺失的或者被篡改的 不然用户访问的数据就是不正确的。在实际编写代码中，一定要保证数据的完整性，通常的做法是对数据进行签名和校验（比如 MD5和数字签名等）。
- 可用性。 服务需要是可用的。如果连服务都不可用，也就没有安全这一说了。对于这种情况通常使用访问控制、限流等手段解决。
以上三点是安全中最基本的三个要素，后面谈到的 Web 安全问题，都是围绕这三点来展开的。

#### SQL 注入

SQL 注入是注入式攻击中的常见类型，即由于未将代码与数据进行严格的隔离 ，导致在读取用户数据的时候，错误地把数据作为代码的一部分执行而导致一些安全问题。
预防手段：
1. 过滤用户输入参数中的特殊字符 ，从而降低被 SQL注入的风险。
2. 禁止通过字符串拼接的 SQL 语句 ，严恪使用参数绑定传入的 SQL 参数。
3. 合理使用数据库访问框架提供的防注入机制。

#### XSS 与 CSRF

跨站脚本攻击，即`Cross-Site Scripting` ，为了不和前端开发中层叠样式表 `CSS` 的名字冲突，简称为XSS。 XSS 是指黑客通过技术手段，向正常用户请求的 HTML 页面中插入恶意脚本，从而可以执行任意脚本。 XSS主要分为反射型 XSS 、存储型 XSS和DOM型XSS。XSS 主要用于信息窃取、破坏等目的。
跨站请求伪造（ Cross-Site Request Forgery ），简称 CSRF， 也被称为 One-click Attack，即在用户并不知情的情况下，冒充用户发起请求，在当前已经登录的 Web 应用程序上执行恶意操作，如恶意发帖、修改密码、发邮件等。
在防范 XSS 上，主要通过对用户输入数据做过滤或者转义。比如 Java 开发人员可以使用 Jsoup 框架对用户输入字符串做 XSS 过滤，或者使用框架提供的工具类对用户输入的字符串做 HTML 转义，例如 Spring 框架提供的 HtmlUtils 。前端在浏览器展示数据时，也需要使用安全的 API 展示数据，比如使用 innerText 而不是innerHTML 。

CSRF 有别于 XSS ，从攻击效果上，两者有重合的地方。从技术原理上两者有本质的不同，XSS 是在正常用户请求的 HTML 页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用用户浏览器中的登录信息，冒充用户去执行黑客指定的操作。
防范 CSRF 漏洞主要通过以下方式：
1. CSRF Token 验证，利用浏览器的同源限制，在 HTTP 接口执行前验证页面或者 Cookie 中设置的 Token ，只有验证通过才继续执行请求。
2. 人机交互 ，比如在调用上述网上银行转账接口时校验短信验证码。

XSS 问题出在用户数据没有过滤、转义；CSRF 问题出在 HTTP 接口没有防范不受信任的调用。

#### HTTPS
安全套接字层( Secure Socket Layer, SSL ）。SSL 协议工作于传输层与应用层之间，为应用提供数据的加密传输。而 HTTPS 的全称是 HTTP over SSL ，简单的理解就是在之前的 HTTP 传输上增加了 SSL 协议的加密能力。

我们可以通过对称加密算法对数据进行加密，比如 DES ，即 一个主站与用户之间可以使用相同的密钥对传输内容进行加解密。但密钥几乎没有什么保密性可言，被盗之后就会被破解。

RSA 把密码革命性地分成公钥和私钥，由于两个密钥并不相同，所以称为非对称加密。私钥是用来对公钥加密的信息、进行解密的，是需要严格保密的。公钥是对信息进行加密，任何人都可以知道，包括黑客。
非对称加密的安全性是基于大质数分解的困难性，在非对称的加密中公钥和私钥是一对大质数函数。计算两个大质数的乘积是简单的，但是这个过程的逆运算（即将这个乘积分解为两个质数）是非常困难的。而在 RSA 的算法中，从一个公钥和密文中解密出明文的难度等同于分解两个大质数的难度。因此在实际传输中，可以把公钥发给对方。一方发送信息时，使用另一方的公钥进行加密生成密文。收到密文的一方再用私钥进行解密，这样一来，传输就相对安全了。
但是非对称加密并不是完美的，它有一个很明显的缺点是加密和解密耗时长，只适合对少量数据进行处理。而且在解决了加密危机之后又产生了信任危机。

CA ( Certificate Authority）就是颁发 HTTPS 证书的组织。 HTTPS 是当前网站的主流文本传输协议，在基于 HTTPS 进行连接时，就需要数字证书。

```
访问一个 HTTPS 的网站的大致流程如下：
1. 浏览器向服务器发送请求，请求中包括浏览器支持的协议，并附带一个随机数。
2. 服务器收到请求后，选择某种非对称加密算法，把数字证书签名公钥、身份信息发送给浏览器，同时也附带一个随机数。
3. 浏览器收到后，验证证书的真实性，用服务器的公钥发送握手信息给服务器。
4. 服务器解密后，使用之前的随机数计算出一个对称加密的密钥，以此作为加密信息并发送。
5. 后续所有的信息发送都是以对称加密方式进行的。
```

传输层安全协议（ Transport Layer Security，TLS）的概念。这里先解释 TLS和SSL 的区别。 TLS 可以理解成 SSL 协议 3.0 版本的升级，所以 TLS 1.0 版本也被标识为 SSL 3.1 版本。但对于大的协议栈而言，SSL 和 TLS 并没有太大的区别，因此在 Wireshark 里，分层依然用的是安全套接字层（SSL）标识。

在整个 HTTPS 的传输过程中，主要分为两部分：首先是 HTTPS 的握手，然后是数据的传输。前者是建立一个 HTTPS 的通道，并确定连接使用的加密套件及数据传输使用的密钥。而后者主要使用密钥对数据加密并传输。

首先来看 HTTPS 是如何进行握手的，如图 1-28 所示是一个完整的 SSL 数据流和简单流程。

![1565768288645](E:\git_repo\Hao_Learn\2019\8\img\1565768288645.png)

第一，客户端发送了 Client Hello 协议的请求：在 Client Hello 中最重要的信息是 Cipher Suites 字段，这里客户端会告诉服务端自己支持哪些加密的套件。比如在这次 SSL 连接中，客户端支持的加密套件协议如图 1-29 所示。

![1565768515498](E:\git_repo\Hao_Learn\2019\8\img\1565768515498.png)

第二，服务端在收到客户端发来的 Client Hello 的请求后，会返回一系列的协议数据，并以一个没有数据内容的 Server Hello Done 结束。这些协议数据有的是单独发送，有的则是合并发送， 这里分别解释下几个比较重要的协议，如图 1-30 所示。

![1565768642195](E:\git_repo\Hao_Learn\2019\8\img\1565768642195.png)

1. Server Hell 协议。
	主要告知客户端后续协议中要使用的 TLS 协议版本，这个版本主要和客户端与服务端支持的最高版本有关。比如本次确认后续的 TLS 协议版本是 TLS v1.2 ，并为本次连接分配 个会话 ID ( Session ID ）。此外，还会确认后续采用的加密套件（ Cipher Suite ）， 这里确认使用的加密套件为TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 。该加密套件的基本含义为：使用非对称协议加密 （RSA） 进行对称协议加密 （AES） 密钥的加密，并使用对称加密协议 （AES） 进行信息的加密。
2. Certificate 协议。
	主要传输服务端的证书内容。
3. Server Key Exchange。
	如果在 Certificate 协议中未给出客户端足够的信息，则会在 Server Key Exchange 进行补充。比如在本次连接中 Certificate 未给出证书的公钥 （Public Key）， 这个公钥的信息将会通过 Server Key Exchange 发送给客户端。
4. Certificate Request。
	这个协议是一个可选项，当服务端需要对客户端进行证书验证的时候，才会向客户端发送一个证书请求（Certificate Request）。
5. 最后以 Server Hello Done 作为结束信息，告知客户端整个 Server Hello 过程结束。

第三，客户端在收到服务端的握手信息后，根据服务端的请求，也会发送一系列的协议。

1. Certificate。
	它是可选项。因为上文中服务端发送了 Certificate Request 需要对客户端进行证书验证，所以客户端要发送自己的证书信息。
2. Client Key Exchange。
	它与上文中 Server Key Exchange 类似， 是对客户端 Certificate 信息的补充。
3. Certification Verity。 
	对服务端发送的证书信息进行确认。
4. Change Cipher Spec。
	该协议不同于其他握手协议（Handshake Protocol ），而是作为一个独立协议告知服务端，客户端已经接收之前服务端确认的加密套件，并会在后续通信中使用该加密套件进行加密。
5.  Encrypted Handshake Message。
	用于客户端给服务端加密套件加密一段 Finish 的数据，用以验证这条建立起来的加解密通道的正确性。

第四，服务端在接收客户端的确认信息及验证信息后，会对客户端发送的数据进行确认，这里也分为几个协议进行回复。

1. Change Cipher Spec。
	通过使用私钥对客户端发送的数据进行解密，并告知后续将使用协商好的加密套件进行加密传输数据。
2. Encrypted Handshake Message。
	与客户端的操作相同，发送一段 Finish 的加密数据验证加密通道的正确性。

最后，如果客户端和服务端都确认加解密无误后，各自按照之前约定的 Session Secret 和 Application Data 进行加密传输。


# 第二章 面向对象

## 2.1 OOP 理念

面向过程的结构相对松散，强调如何流程化地解决问题；面向对象的思维更加内聚，强调高内聚、低藕合，先抽象模型，定义共性行为，再解决实际问题。

面向对象思维，以对象模型为核心，丰富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象能力显得尤为重要；封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，更具有维护性；继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有复用性；多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间。抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础。

#### 抽象

在面向对象的思维中，抽象分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行归一化的逻辑思维过程；后者则是从本质到具体，从共性到个性，逐步形象化的过程。在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已有问题解决方案的基础上，正确地找到合适的使用场景。

Java 之父 Gosling 设计的 Object 类，是任何类的默认父类，是对万事万物的抽象，是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。

|抽象问题|Object类的实现|
|------|--------|
|我是谁？|getClass() 说明本质上是谁，而 toString() 是当前职位的名片。|
|我从哪里来？|Object() 构造方法是生产对象的基本步骤，clone() 是繁殖对象的另一种方式。|
|我到哪里去？|finalize() 在对象销毁时触发的方法。|
|世界是否因你而不同？|hashCode() 和 equals() 就是判断与其他元素是否相同的一组方法。|
|与他人如何协调？|wait() 和 notify() 是对象间通信与协作的一组方法。|

clone()  方法分为浅拷贝、一般深拷贝和彻底深拷贝 。浅拷贝只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指向的实际对象；而彻底深拷贝是在成功 clone 一个对象之后，此对象与母对象在任何引用路径上都不存在共享的实例对象 ，即**深拷贝把所有引用变量所指向的变量都拷贝了一份**，但是引用路径递归越深，则越接近 JVM 底层对象，且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深拷贝。归根结底， 慎用 Object 的 clone() 方法来拷贝对象，因为对象的 clone() 方法默认是浅拷贝，若想实现深拷贝，则需要覆写 clone () 方法实现引用对象的深度遍历式拷贝。

随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如 finalize()方法在 JDK9 之后直接被标记为过时方法。而 wait() 和 notify() 同步方式事实上已经被同步信号、锁、阻塞集合等取代。

#### 封装

封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感方法或者外部不需要感知的复杂逻辑处理， 一般也会进行封装。封装使面向对象的世界变得单纯，对象之间的关系变得简单，各人自扫门前雪，耦合度变弱，有利于维护。

设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即 A模块使用
B 模块的某个接口行为，对 B 模块中除此行为之外的其他信息知道得尽可能少。

#### 继承

继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系，形成一个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用，父类的能力通过这种方式赋予子类。继承把代码变得更有层次感，更有扩展性，为多态打下语法基础。

人人都说继承是 is-a 关系，那么如何衡量当前的继承关系是否满足 is-a 关系呢？判断标准即是否符合里氏代换原则（ Liskov Substitution Principle, LSP ）。 LSP 是指任何父类能够出现的地方，子类都能够出现。在实际代码环境中，如果父类引用直接使用子类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个类之间符合 LSP 原则，可以使用继承关系。

继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样容易被滥用，我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆炸。

方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为的能力 ，比如鸟会飞，驼鸟继承鸟，发现飞不了，这就是方法污染。子类继承父类则说明子类对象可以调用父类对象的一切行为。在这样的情况下，总不能在继承时，添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方法，抛出异常，以阻止别人的调用。

方法爆炸是指继承树不断扩大，底层类拥有的方法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，很容易在实际编程中产生选择困难症。在实际故障中，因为方法爆炸，父类的某些方法签名和子类非常相似，在 IDE 中，输入`类名＋. `之后，在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述，提倡组合优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而不是继承。

#### 多态

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。

我们来明确两个非常容易混淆的概念 `override` 和 `overload`，`override`译成 `覆写`， 是子类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是**垂直方向**上行为的不同实现。`overload`译成`重载`，方法名称是相同的，但是参数类型或参数个数是不相同的，是**水平方向**上行为的不同实现。

多态是指在编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由 JVM 进行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。严格意义上来说，多态并不是面向对象的一种特质，而是一种由继承行为衍生而来的进化能力而已。

## 2.3 类

类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有 public 和无访问控制符，类型分 class、interface、enum。
Java 类主要由两部分组成：成员和方法。在定义 Java 类时，推荐首先定义变量，然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展示；保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法，因此重要性仅次于公有方法；而私有方法对外部来说是一个黑盒实现，因此一般不需要被特别关注；最后是 gette /setter 方法，虽然它们也是公有方法，但是因为承载的信息价值较低，一般不包含业务逻辑，所以所有 getter/setter 方法须放在类最后。

#### 接口与抽象类

定义类的过程就是抽象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行为和特征。

|语法维度|抽象类|接	口|
|------------|----------|------------|
|定义关键字|abstract|interface|
|子类继承或实现关键字|extends|implements|
|方法实现|可以有|不能有，但在JDK8及之后，允许有default实现|
|方法访问控制符|无限制|有限制，默认是public abstract类型|
|属性访问控制符|无限制|有限制，默认是public static final类型|
|静态方法|可以有|不能有|
|static{} 静态代码块|可以有|不能有|
|本类型之间扩展|单继承|多继承|
|本类型之间扩展关键字|extends|extends|

抽象类在被继承时体现的是 `is-a` 关系，接口在被实现时体现的是 `can-do` 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等 于一个接口。 `is-a`关系需要符合里氏代换原则；`can-do`关系要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为。

抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，性格偏内向，可以存在不同版本的实现；接口是开放的，性格偏外向，它就像一份合同，定义了方法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它，但想实现它的类必须遵守这份接口约定合同。

接口是顶级的“类”，虽然关键字是 interface ，但是编译之后的字节码扩展名还
`.class`。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后实现部分接口行为，其中 AbstractCollection 是最典型的抽象类：

```java
public abstract class AbstractCollection<E> implements Collection<E> {
	//Collection 定义的抽象方法，但本类没有实现
	//Collection 接口定义的方法，size()这个方法对于链表和顺序表有不同的实现方式
	public abstract int size();
	
	//实现Collection接口的这个方法，因为对AbstractCollection的子类他们判空的方式的一致的，这就是模板式设计，对于所有他的子类,实现共同的方法体，通过多态调用到子类的具体size()实现
	public boolean isEmpty(){
		return size() == 0;
	}
}
```

Java 语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的绑定机制会变得非常复杂。接口继承接口，关键字是 extends ，而不是 implements，允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实体类在实现多重继承后的接口时，只是说明`can do many things `。当纠结定义接口还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接口，然后再用抽象类去 implements 某些接口，这样做可方便后续的扩展和重构。

#### 内部类

在一个 `.java` 源文件中，只能定义一个类名与文件名完全一致的公开类，使用`public class` 关键字来修饰。但在面向对象语言中，任何一个类都可以在内部定义另外一个类 ，前者为外部类，后者为内部类。内部类本身就是类的一个属性 ，与其他属性定义方式一致。



比如，属性字段`private static String str` ，由访问控制符、是否静态、类型、变量名组成，而内部类 `private static class Inner{}`，也是按这样的顺序来定义的，类型
可以为 class、enum ，甚至是 interface ，当然在内部类中定义接口是不推荐的。

内部类具体分为如下四种：
- 静态内部类，如： static class StaticInnerClass {} ;
- 成员内部类，如： private class InstancelnnerClass {} ;
- 局部内部类，定义在方法或者表达式内部；
- 匿名内部类，如： (new Thread () {} ).start() 。

无论是什么类型的内部类，都会编译成一个独立的 `.class` 文件。

![1565878774945](E:\git_repo\Hao_Learn\2019\8\img\1565878774945.png)



外部类与内部类之间使用 $ 符号分隔，匿名内部类使用数字进行编号，而方法内部类，在 类名前还有一个编号来标识是哪个方法。匿名内部类和静态内部类是比较常用的方式。而
静态内部类是最常用的内部表现形式，外部可以使用 OuterClass.StaticInnerClass 直接访问，类加载与外部类在同一个阶段进行，JDK 源码中，定义包内可见静态内部类的方式很常见，这样做的好处是：作用域不会扩散到包外；可以通过`外部类 内部类`的方式直接访问；内部类可以访问外部类申的所有静态属性和方法。

```Java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next ; 
}
```
如上所示的源码是在 ConcurrentHashMap 中定义的 Node 静态内部类，用于表示一个节点数据，属于包内可见 ，包内其他集合要用到这个 Node 直接使用
`ConcurrentHashMap.Node`。
仅包内可见可以阻止外部程序随意使用此类来生成对象，Node的父类 Entry 是 Map 的静态内部类，之所以可以被 Node 成功继承，是因为两个外部类同属一个包。
在 JDK 源码中，使用内部类封装某种属性和操作的方式比较常见，比如应用类加载器 Launcher的AppClassLoader, ReentrantLock中 AbstractQueuedSynchronizer 的内部类 Sync, ArrayList 中的私有静态内部类SubList。内部类中还可以定义内部类，形成多层嵌套 如在 ThreadLocal 静态内部类 ThreadLocalMap 中还定义一个内部类 Entry。

![1565879947217](E:\git_repo\Hao_Learn\2019\8\img\1565879947217.png)

#### 访问权限控制
面向对象的核心思想之一就是封装，只把有限的方法和成员公开给别人，这也是迪米特法则的内在要求，使外部调用方对方法体内的实现细节知道得尽可能少。如何实现封装呢？需要使用某些关键字来限制类外部对类内属性和方法的随意访问，这些关键字就是访问权限控制符。在

在任何情况下，类外部实例化出来的对象均无法调用私有方法。

![1565880777933](E:\git_repo\Hao_Learn\2019\8\img\1565880777933.png)

无访问权限控制符仅对包内可见，但千万不要说成 default，它并非访问权限控制符的关键字 ，另外，在 JDK8 接口中引入 default 默认方法实现，更加容易混淆两者释义。

在定义类时，推荐访问控制级别从严处理：
1. 如果不允许外部直接通过 new 创建对象，构造方法必须是 private。
2. 工具类不允许有 public 或 default 构造方法。
3. 类非静态成员变雪并且与子类共享，必须是 protected。
4. 类非静态成员变量并且仅在本类使用，必须是 private。
5. 类静态成员变量如果仅在本类使用，必须是 private。
6. 若是静态成员变量，必须考虑是否为 final。
7. 类成员方法只供类内部调用，必须是 private。
8. 类成员方法只对继承类公开，那么限制为 protected。

#### this 与 super

对象实例化时，至少有一条从本类出发抵达 0bject 的通路，而打通这条路的两个主要工兵就是 this 和 super ，逢山开路，遇水搭桥。但是 this 和 super 往往是默默无闻的，在很多情况下可以省略，比如：
- 本类方法调用本类属性。
- 本类方法调用另一个本类方法。
- 子类构造方法隐含调用 super () 。

任何类在创建之初，都有一个默认的空构造方法，它是 super ()  的一条默认通路。构造方法的参数列表决定了调用通路的选择；如果子类指定调用父类的某个构造方法，super 就会不断往上溯源；如果没有指定，则 默认调用 super () 。**如果父类没有提供默认的构造方法，子类在继承时就会编译错误**，如果父类坚持不提供默认的无参构造方法，必须在本类的无参构造方法中使用super 方式调用父类的有参构造方法。

如果 this 和 super 指代构造方法，则必须**位于方法体的第一行**。在一个构造方法中， this 和 super **只能出现一个 ，且只能出现一次**，否则在实例化对象时，会因子类调用到多个父类构造方法而造成混乱。

由于 this 和 super 都在实例化阶段调用，所以不能在静态方法和静态代码块中使用 this 和 super 关键字。this 还可以指代当前对象，比如在 同步步代码块`synchronized(this){...}`中，super 并不具备此能力。但 super 也有自己的特异功能，字类覆写父类方法时，可以使用 super 调用父类同名的实例方法。
![1565965442824](E:\git_repo\Hao_Learn\2019\8\img\1565965442824.png)


#### 类关系

证明类之间没关系是一个涉及业务、架构、模块边界的问题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了没有关系的点，就可以如启丁解牛一样，进行架构隔离、模块解相等工作。有关系的情况下，包括如下5种类型：

- 继承：extends (is-a)
- 实现：implements (can-do)
- 组合：类是成员变量 (contains-a)
- 聚合：类是成员变量 (has-a)
- 依赖：import类 (use-a)

继承和实现是比较容易理解的两种类关系。在架构设计中，要注意组合、聚合和
依赖这三者的区别。组合体现的是非常强的整体与部分的关系， 同生共死，部分不能在整体之间共享；聚合是一种可以拆分的整体与部分的关系，是非常松散的暂时组合，部分可以被拆出来给另一个整体；
依赖是除组合和聚合外的类与类之间的关系，这个类只要 import ，那就是依赖关系。

![1565966007465](E:\git_repo\Hao_Learn\2019\8\img\1565966007465.png)

随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待类图。在业务重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一种演变。



#### 序列化

内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数据对象转换为二进制流的过程称为对象的序列化（ Serialization ）。反之，将二进制流恢复为数据对象的过程称为反序列化（ Deserialization ）。序列化需要保留充分的信息以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可能小。序列化常见的使用场景是RPC框架的数据传输。常见的序列化方式有三种：
1. Java 原生序列化。
	Java 类通过实现 Serializable 接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用。Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不支持跨语言，而且性能一般。
	实现 Serializable 接口的类建议设置 serialVersionUID 字段值，如果不设置，那么每次运行时，编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自动生成 serialVersionUID 。如果类的源代码有修改，那么重新编译后serialVersionUID 的取值可能会发生变化。因此实现 Serializable 接口的类一定要显式地定义serialVersionUID 属性值。修改类时需要根据兼容性决定是否修改 serialVersionUID值：
	- 如果是兼容升级，请不要修改 serialVersionUID 字段，避免反序列化失败。
	- 如果是不兼容升级，需要修改 serialVersionUID 值，避免反序列化混乱。
	使用 Java 原生序列化需注意， Java 反序列化时**不会调用类的无参构造方法，而是调用 native 方法将成员变量赋值为对应类型的初始值**。基于性能及兼容性考虑，不推荐使用 Java 原生序列化。

2.  Hessian 序列化。 
	Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。 Java 对象序列化的二进制流可以被其他语言（如 C++、Python ）反序列化。 Hessian 协议具有如下特性：
	- 自描述序列化类型。不依赖外部描述文件或接口定义，用一个字节表示常用基础类型，极大缩短二进制流。
	- 语言无关，支持脚本语言。
	- 协议简单，比 Java 原生序列化高效。
	相比 Hessian 1.0，Hessian 2.0 中增加了压缩编码，其序列化二进制流大小是 Java序列化的 50% 序列化耗时是 Java 序列化的 30 ，反序列化耗时是 Java 反序列化的20%。
	Hessian 会把复杂对象所有属性存储在一个 Map 中进行序列化。所以在父类、子类存在同名成员变量的情况下，Hessian 序列化时，先序列化子类 ，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖。
3.  JSON 序列化。
	JSON ( JavaScript Object Notation ）是一种轻量级的数据交换格式。 JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，JSON 可读性比较好，方便调试。

序列化通常会通过网络传输对象，而对象中往往有敏感数据，所以序列化常常成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序列化的过程中执行任意代码。 Java 工程中广泛使用的 Apache Commons Collections、Jackson、fastjson 等都出现过反序列化漏洞。如何防范这种黑客攻击呢？有些对象的敏感属性不需要进行序列化传输 ，可以加 `transient` 关键字，避免把此属性信息转化为序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的安全防范意识，对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受到攻击。

## 2.4 方法

#### 方法签名

方法签名包括方法名称和参数列表，是 JVM 标识方法的唯一索引，不包括返回值，更加不包括访问权限控制符、异常类型等。

无论是对于基本数据类型，还是引用变量， Java 中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引用变量修改指向对象的相关属性。

**可变参数**是在 JDK5 版本中引入的，主要为了解决当时的反射机制和 printf 方法问题，适用于不确定参数个数的场景。可变参数通过“参数类型 ..．”的方式定义，如 PrintStream 类中 printf 方法使用了可变参数：

```Java
public PrintStream printf(String format , Object ... args) {
	return format (format , args) ;
}
//调用printf方法示例
System.out.printf("%d", n); 	//第1处
System.out.printf("%d %s",n,"something");	//第2处
```

看上去可变参数使方法调用更简单，省去了手工创建数组的麻烦。如果在实际开发过程中使用不当，会严重影响代码的可读性和可维护性。因此，使用时要谨慎小心，尽量不要使用可变参数编程。如果一定要使用，则只有相同参数类型，相同业务含义的参数才可以，并且一个方法中只能有一个可变参数，且这个可变参数必须是该方法的最后一个参数。此外，建议不要使用 Object 作为可变参数。

参数预处理包括两种：
1. 入参保护。
	虽然“入参保护”被提及的频率和认知度远低于参数校验，但是其重要性却不能被忽略。入参保护实质上是对服务提供方的保护，常见于批量接口。虽然批量接口能处理一批数据，但其处理能力并不是无限的，因此需要对入参的数据量进行判断和控制，如果超出处理能力，可以直接返回错误给客户端。
2. 参数校验。
	基于防御式编程理念，在方法内，无论是对方法调用方传入参数的理性不信任 ，还对参数有效值的检测都是非常有必要的。但是由于方法间交互是非常频繁的，如果所有方法都进行参数校验，就会导致重复代码及不必要的检查影响代码性能。综合两个方面考虑，汇总需要进行参数校验和无须处理的场景。

需要进行参数校验的场景：
- 调用频度低的方法。
- 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但 如果因为参数错误导致中间执行回退或者错误，则得不偿失。
- 需要极高稳定性和可用性的方法。
- 对外提供的开放接口。
- 敏感权限入口。

不需要进行参数校验的场景：
- 极有可能被循环调用的方法，但在方法说明里必须注明外部参数检查。
- 底层调用频度较高的方法。参数错误不太可能到底层才会暴露问题。一般DAO层与 Service 层都在同一个应用中，部署在同一台服务器中，所以可以省略DAO 的参数校验。
- 声明成 private 只会被自己代码调用的方法。如果能够确定调用方法的代码传
入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。

#### 构造方法
构造方法（ Constructor ）是方法名与类名相同的特殊方法，在新建对象时调用，可以通过不同的构造方法实现不同方式的对象初始化，它有如下特征：
1. 构造方法名称必须与类名相同。
2. 构造方法是没有返回类型的，即使是void也不能有。**它返回对象的地址，并赋值给引用变量**。
3. 构造方法不能被继承，不能被覆写，不能被直接调用。调用途径有三种：一是通过 new 关键字，二是在子类的构造方法中通过 super 调用父类的构造方法，三是通过反射方式获取并使用。
4. 类定义时提供了默认的无参构造方法。但是如果显式定义了有参构造方法，此无参构造方法就会被覆盖；如果依然想拥有，就需要进行显式定义。
5. 构造方法可以私有。外部无法使用私有构造方法创建对象。

在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在，它可以定，但不能加 public 修饰，因为它默认是 private 的，是绝对的单例，不允许外部以创建对象的方式生成枚举对象。

单一职责，对于构造方法同样适用 ，构造方法的使命就是在构造对象时进行传参操作，所以不应该在构造方法中引入业务逻辑。推荐将初始化业务逻辑放在某个方法中，比如 init() ， 当对象确认完成所有初始化工作之后，再显式调用。

类中的 static { ... ｝代码被称为类的静态代码块，在类初始化时执行，优先级很高，且只运行一次，在第二次对象实例化时，不会运行。

父子类静态代码块和构造方法的执行顺序：
1. 父类静态代码块
2. 子类静态代码块
3. 父类构造方法
4. 子类构造方法

#### 类内方法

除构造方法外，类中还可以有三类方法：实例方法、静态方法、静态代码块。

1. 实例方法
	又称为非静态方法。实例方法比较简单，它必须依附于某个实际对象，并可以通过引用变量调用其方法。类内部各个实例方法之间可以相互调用，也可以直接读写类内变量 ，且不用通过 this 。**当 .class 字节码文件加载之后，实例方法并不会被分配方法入口地址，只有在对象创建之后才会被分配**。实例方法可以调用静态变量和静态方法，当从外部创建对象后，应尽量使用`类名.静态方法`来调用，而不是对象名，一来为编译器减负，二来提升代码可读性。

2. 静态方法
	又称为类方法。当类加载后，即分配了相应的内存空间，由于生命周期的限制，使用静态方法需要注意两点：
	- 静态方法中不能使用实例成员变量和实例方法。
	- 静态方法不能使用 super 和 this 关键字 ，这两个关键字指代的都是需要被创建出来的对象。
	通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，那么在并发时会存在线程安全问题。所以，**工具类的静态方法与单例通常是相伴而生的**。

3. 静态代码块
	在代码的执行方法体中，非静态代码块和静态代码块比较特殊。非静态代码块又称为局部代码块，是极不推荐的处理方式，本节不再展开。而静态代码块在类加载的时候就被调用，并且只执行一次。静态代码块是先于构造方法执行的特殊代码块。静态代码块不能存在于任何方法体内，包括类静态方法和属性变量。
	某框架的初始化代码如下所示：
```Java
public class RpcProviderBean｛
    public void init() throws RpcRuntimeException {
        this.initRegister();
        this.publish();
        //其他逻辑
    }
    public void initRegister() {
        if (this.inited.compareAndSet (false, true)) {
            this.checkConfig() ;
            this.metadata.init() ;
        }
    }
    public void publish( ) {
    //将本地服务信息、发送到注册中心
    }
}
```

#### getter 与 setter

在实例方法中有一类特殊的方法，即 getter 与 setter 方法，它们一般不包含任何业务逻辑，仅仅是为类成员属性提供读取和修改的方法，这样设计有两点好处：
1. 满足面向对象语言封装的特性。 
	尽可能将类中的属性定义为 private ，针对属性值的访问与修改需要使用相应的 getter 与 setter 方法 而不是直接对 public 的属性进行读取和修改。
2. 有利于统一控制。 
	虽然直接对属性进行读取、修改的方式和使用相应的getter 与 setter 方法在效果上是一样的，但是前者难以应对业务的变化。例如，业务要求对某个属性值的修改要增加统一的权限控制，如果有 setter 作为统一的属性修改方法更容易实现，这种情况在一些使用反射的框架中作用尤其明显。

建议在类定义中，类内方法定义顺序依次是：公有方法或保护方法＞私有方法＞ getter/setter 方法。

最典型的 getter 与 setter 方法使用是在 POJO ( Plain Ordinary Java Object， 简单的Java 对象）类中。常见的 POJO 类包括 DO(Domain Object)、 BO(Business Object)、 DTO(Data Transfer Object)、 VO （View Object）、 AO(Application Object)。

#### 同步与异步

同步调用是刚性调用，是阻塞式操作，必须等待调用方法体执行结束。而异步调用是柔性调用，是非阻塞式操作，在执行过程中，如调用其他方法，自己可以继续执行而不被阻塞等待方法调用完毕。

异步调用通常用在某些耗时长的操作上，这个耗时方法的返回结果，可以使用某种机制反向通知，或者再启动一个线程轮询。反向通知方式需要异步系统和各个调用它的系统进行耦合，而轮询对于没有执行完的任务会不断地请求，从而加大执行机器的压力。

异步处理的任务是非时间敏感的。比如，在连接池中，异步任务会定期回收空闲
线程。

#### 覆写
为有些子类是延迟加载的，甚至是网络加载的，所以最终的实现需要在运行期判断，这就是所谓的动态绑定。动态绑定是多态性得以实现的重要因素，元空间有一个方法表保存着每个可以实例化类的方法信息， JVM可以通过方法表快速地激活实例方法。
如果某个类覆写了父类的某个方法，则方法表中的方法指向引用会指向子类的实现处，通常这也被称作向上转型。

向上转型时，通过父类引用执行子类方法时需要注意以下两点：
1. 无法调用到子类中存在而父类本身不存在的方法。
2. 可以调用到子类中覆写了父类的方法，这是一种多态实现。

想成功地覆写父类方法，需要满足以下 4个条件：
1. 访问权限不能变小。
	访问控制权限变小意味着在调用时父类的可见方法无法被子类多态执行，比如父类中方法是用 public 修饰的，子类覆写时变成 private ，则破坏了封装。
2. 返回类型能够向上转型成为父类的返回类型。
	虽然方法返回值不是方法签名的一部分，但是在覆写时，父类的方法表指向了子类实现方法 ，编译器会检查返回值是否向上兼容。注意，这里的向上转型必须是严格的继承关系，数据类型基本不存在通过继承向上转型的问题。比如 int 与 Integer 是非兼容返回类型，不会自动装箱；再比如，如果子类方法返回 int ，而父类方法返回 long ，虽然数据表示范围更大，但是它们之间没有继承关系；返回类型是 Object 的方法，能够兼容任何对象，包括class、 enum、 interface 等类型。
3. 异常也要能向上转型成为父亲的异常。
	异常分为 checked 和 unchecked 两种类型。如果父类抛出一个 checked 异常，则子类只能抛出此异常或此异常的子类。而 unchecked 异常不用显式地向上抛出，所以没有任何兼容问题。
4. 方法名、参数类型及个数必须严格一致。
	为了使编译器准确地判断是否是覆写行为 ，所有的覆写方法必须加＠Override 注解。此时编译器会自动检查覆写方法签名是否一致，避免了覆写时因写错方法名或方法参数而导致覆写失败。

综上所述，方法的覆写可以总结成容易记忆的口诀：`一大两小两同`。
	- 一大：子类的方法访问权限控制符只能相同或变大。
	- 两小：抛出异常和返回值只能变小，且能够转型成父类对象。子类的返回值、抛出异常类型必须与父类的返回值、抛出异常类型存在继承关系。
	- 两同：方法名和参数必须完全相同。

覆写只能针对非静态、非 final 、非构造方法。由于静态方法属于类，如果父类和子类存在同名静态方法，那么两者都可以被正常调用。如果方法有 final 修饰 ，则表示此方法不可被覆写。

如果想在子类覆写的方法中调用父类方法 ，则可以使用 super 关键字。

## 2.5 重载

在同一个类中，如果多个方法有相同的名字、不同的参数，即称为重载，比如一个类中有多个构造方法。String类中的 valueOf 也是比较著名的重载案例，它有9 个方法，可以将输入的基本数据类型、数组、 Object 等转化成为字符串。

![1566035631923](E:\git_repo\Hao_Learn\2019\8\img\1566035631923.png)

![1566035609428](E:\git_repo\Hao_Learn\2019\8\img\1566035609428.png)

第一处与第二处的区别是后者加了 varargs 标识，即可变参数了 varargs 标识，即可变参数，参数个数可以是 0 或多个，也就是说，它和第1、 2、3 个方法都是有可能争抢地盘的。

JVM 在重载方法中，选择合适的目标方法的顺序如下：
1. 精确匹配。
2. 如果是基本数据类型，自动转换成更大表示范围的基本类型。
3. 通过自动拆箱与装箱。
4. 通过子类向上转型继承路线依次匹配。
5. 通过可变参数匹配。

null 可以匹配任何类对象，在查找目标方法时，是从最底层子类依次向上查找的。

父类的公有实例方法与子类的公有实例方法可以存在重载关系。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法。所以，重载又称为静态绑定。

## 2.6 泛型

泛型的本质是类型参数化，解决不确定具体对象类型的问题。在面向对象编程语言中，允许程序员在强类型校验下定义某些可变部分，以达到代码复用的目的。
Java 在引入泛型前，表示可变类型 ，往往存在类型安全的风险。
泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来
解析泛型。在泛型定义时，约定俗成的符号包括 E 代表 Element ，用于集合中的元素；T 代表 the Type of object ，表示某个类；K 代表 key、V 代表 Value ，用于键值对元素。

1. 尖括号里的每个元素都指代一种未知类型，如 String 出现在尖括号里，它就不是 java.lang.String ，而仅仅是一个代号。类名后方定义的泛型`<T>`和 get ()前方定义的`<T>`是两个指代，可以完全不同，互不影响。
2. 尖括号的位置非常讲究，必须在类名之后或方法返回值之前。
3. 泛型在定义处只具备执行Object方法的能力，因此想在 get() 内部执行string.longValue() + alibaba.intValue() 是做不到的，此时泛型只能调用 Object 类中的方法，如 toString() 。
4. 对于编译之后的字节码指令，其实没有这些花头花脑的方法签名，充分说明了泛型只是一种编写代码时的语法检查。在使用泛型元素肘，会执行强制类型转换。

![1566038549508](E:\git_repo\Hao_Learn\2019\8\img\1566038549508.png)

这就是坊间盛传的类型擦除。 CHECKCAST 指令在运行时会检查对象实例的类
型是否匹配，如果不匹配，则抛出运行时异常 ClassCastxception 。

泛型就是在编译期增加了一道检查而己，目的是促使程序员在使用泛型时安全放置和使用数据。使用泛型的好处包括：
	- 类型安全。放置的是什么，取出来的自然是什么，不用担心会抛出ClassCastException 异常。
	- 提升可读性。从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么
	- 代码重用。泛型合并了同类型的处理代码，使代码重用度变高。

## 2.7 数据类型

#### 基本数据类型

基本数据类型是指不可再分的原子数据类型，内存中直接存储此类型的值，通过内存地址即可直接访问到数据，并且此内存区域只能存放这种类型的值。

refvar 是面向对象世界中的引用变量，也叫引用句柄，本书认为它也是一种基本数据类型。

前 8 种都有相应的包装数据类型，除char 的对应包装类名为Character, int 为Integer 外，其他所有对应的包装类名就是把首字母大写即可。

![1566039107712](E:\git_repo\Hao_Learn\2019\8\img\1566039107712.png)

- JVM 并没有针对 boolean 数据类型进行赋值的专用字节码指令，`boolean flag= false` 就是用 CONST ，即常数 0 来进行赋值。
- byte 的默认值以一个字节的 0 表示，在默认值的表示上使用了强制类型转化；。
- char 的默认值只能是单引号的 '\u0000' 表示 NUL ，注意不是 null，它就是一个空的不可见字符，在码表中是第一个，其码值为0，与 '\n' 换行之类的不可见控制符的理解角度是一样的。

引用分成两种数据类型：引用变量本身和引用指向的对象。为了强化这两个概念
的区分，本书把引用变量（ Reference Variable ）称为` refvar` ，而把引用指向的实际对象（ Referred Object ）简称为 `refobj`。

refvar 是基本的数据类型，它的默认值是 null ，存储 refobj 的首地址，可以直接使用双等号`==`进行等值判断。而平时使用 refvar.hashCode() 返回的值，只是对象的某种哈希计算，可能与地址有关，与 refvar 本身存储的内存单元地址是两回事。作为一个引用变量，不管它是指向包装类、集合类、字符串类还是自定义类， refvar 均占4B 空间。**注意它与真正对象 refobj 之间的区别**。无论 refobj 是多么小的对象，最小占用的存储空间是 12B（用于存储基本信息， 称为对象头），但由于存储空间分配必须是 8B 的倍数，所以初始分配的空间至少是 16B 。

一个 refvar 至多存储一个 refobj 的首地址，一个 refobj 可以被多个 refvar 存储下它的首地址，即一个堆内对象可以被多个 refvar 引用指向。如果 refobj 均没有被任何refvar 指向，那么它迟早会被垃圾回收。而 refvar 的内存释放，则与其他基本数据类型类似。

基本数据类型 int 占用 4 个字节，而对应的包装类 Integer 实例对象占用 16 个字节。这里可能会有人问 Integer 里边的代码就只占用 16B ？这是因为字段属性除成员属性 int value外， 其他的如 MAX_VALUE、 MIN_VALUE 等都是静态成员变量在类加载时就分配了内存，与实例对象容量无关。此外，类定义中的方法代码不占用实例对象的任何空间。IntegerCache 是 Integer 的静态内部类，容量占用也与实例对象无关。由于 refobj 对象的基础大小是 12B ，再加上 int是4B，所以 Integer 实例对象占用 16B ，按此推算 Double 对象占用的存储容量是 24B (12+8 ，8 的倍数)。

![1566047545513](E:\git_repo\Hao_Learn\2019\8\img\1566047545513.png)

对象的内部结构分为三块存储区域：
![1566047613016](E:\git_repo\Hao_Learn\2019\8\img\1566047613016.png)

1. 对象头（Object Header）：
	对象头占用 12 个字节，存储内容包括对象标记 (markOop) 和类元信息（klassOop) 。对象标记存储对象本身运行时的数据，如哈希码、 GC 标记、锁信息、线程关联信息等，这部分数据在 JVM 上占用 8 个字节，称为`Mark Word`。为了存储更多的状态信息，对象标记的存储格式是非固定的（具体与JVM的实现有关）。类元信息存储的是对象指向它的类元数据（即 Klass ）的首地址，占用 4个字节，与 refvar 开销一致。
2. 实例数据（Instance Data）：
	存储本类对象的实例成员变量和所有可见的父类成员变量。如 Integer 的实例成员只有一个 `private int value`，占用 4 个字节，所以加上对象头为 16 个字节；再如，上述示例代码的 RefObjDemo 对象大小为 48 个字节，一个子类 RefObjSon 继承 RefObjDemo，即使子类内部是空的， new RefObjSon 的对象也是占用 48 个字节。
3. 对齐填充（Padding）
	对象的存储空间分配单位是 8 个字节，如果一个占用大小为 16 个字节的对象，增加一个成员变量 byte 类型，此时需要占用 17 个字节，但是也会分配 24个字节进行对齐填充操作。
	
#### 包装类型

包装类的存在解决了基本数据类型无法做到的事情：泛型类型参数、序列化、类型转换、高频区间数据缓存，尤其是最后一项。我们都知道 Integer 会缓存`-128 ~ 127` 之间的值，对于 `Integer var = ?`在`-128 ~ 127` 之间的赋值， Integer对象由 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用`==`进行判断，但是这个区间之外的所有数据都会在堆上产生，并不会复用已有对象，这是一个大问题。因此，推荐所有包装类对象之间值的比较，全部使用 equals () 方法。
事实上，除 Float 和 Double 外，其他包装数据类型都会缓存，6 个包装类直接赋值时，就是调用对应包装类的静态工厂方法 valueOf() 。
```java
@HotSpotIntrinsicCandidate
public static Integer valueOf(int i) {
	if (i >= IntegerCache.low && i <= IntegerCache.high)
		return IntegerCache.cache[i + (-IntegerCache.low)];
	return new Integer(i)；
}
```
如上源代码，赋值数据 i 在缓存区间内直接返回缓存中的 Integer 对象，否则就会 new 一个对象。在 JDK9 直接把 new 的构造方法过时，推荐使用valueOf ()，合理利用缓存，提升程序性能。

Boolean使用静态 final 变量定义， valueOf() 就是返回这两个静态值；Integer是唯一可以修改缓存范围的包装类，在 VM options 加入参数
`-XX:AutoBoxCacheMax=7777`，即可设置最大缓存值为 7777。

合理掌握包装类的缓存策略，防止遇到问题是一个方面，使自己的程序性能最大化，更是程序员的情怀所在。在选择使用包装类还是基本数据类型时，推荐使用如下方式：
1. 所有的 POJO 类属性必须使用包装数据类型。
2. RPC 方法的返回值和参数必须使用包装数据类型。
3. 所有的局部变量推荐使用基本数据类型。

#### 字符串

String 是只读字符串，典型的 immutable( 不变的 )对象，对它的任何改动，其实都是创建一个新对象，再把引用指向该对象。 String 对象赋值操作后，会在常量池中进行缓存，如果下次申请创建对象时，缓存中已经存在，则直接返回相应引用给创建者。
StringBuffer 则可以在原对象上进行修改，是线程安全的。 JDK5 引入的 StringBuilder 与 StringBuffer 均继承自 `AbstractStringBuilder`，两个子类的很多方法都是通过`super.方法()` 的方式调用抽象父类中的方法，此抽象类在内部与 String 一样，也是以字符数组的形式存储字符串的。 StringBuilder 是非线程安全的 ，把是否需要进行多线程加锁交给工程师决定操作效率比 StringBuffer 高。线程安全的对象先产生是因为计算机的发展总是从单线程到多线程，从单机到分布式。
在非基本数据类型的对象中，String 是仅支持直接相加操作的对象。这样操作比
较方便，但在循环体内，字符串的连接方式应该使用 StringBuilder的append 方法进行扩展。

# 第三章 代码风格

## 3.1命名规约

抽象类命名使用 Abstract 或 Base 开头。枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下画线隔开。

命名最好望文知义，即在不需要额外解释的情况下，仅从名称上就能够理解某个词句的确切含义，从而减少注释内容，达到自解释的目的。

#### 常量

根据作用域区分，分为全局常量、类内常量、局部常量。全局常量是指类的公开静态属性，使用 public static final 修饰；类内常量是私有静态属性，使用private static final 修饰，局部常量分为方法常量和参数常量，前者是在方法或代码块内定义的常量，后者是在定义形式参数时，增加 final 标识，表示此参数值不能被修改。

![1566090152540](E:\git_repo\Hao_Learn\2019\8\img\1566090152540.png)

常量在代码中具有穿透性，使用甚广。如果没有一个恰当的命名，就会给代码阅读带来沉重的负担，甚至影响对主干逻辑的理解。首当其冲的问题就是到处使用魔法值。魔法值即“共识层面“上的常量，直接以具体的数值或者字符出现在代码中。这些不知所云的魔法值极大地影响了代码的可读性和可维护性。

![1566090865458](E:\git_repo\Hao_Learn\2019\8\img\1566090865458.png)

枚举类型几乎是固定不变的全局常量，使用频率高、范围广，所以枚举常量都需要添加清晰的注释，比如业务相关信息或注意事项等；后续还会再追加，并且没有扩展信息的常量应该用不能实例化的抽象类的全局常量来表示。

![1566090901520](E:\git_repo\Hao_Learn\2019\8\img\1566090901520.png)

系统成长到某个阶段后，重构是种必然选择。优秀的架构设计不是去阻止未来切重构的可能性，毕竟技术枝、业务方向和规模都在不断变化，而是尽可能让重构来得晚一些，重构幅度小一些。

TreeMap 源码中，表示红黑树节点颜色的 RED = false，BLACK = true 就被定义成为类内常量，以方便理解。

## 3.2 代码展示风格

#### 缩进、空格与空行

缩进表示层次对应关系。推荐采用 4 个空格缩进，禁止使用 Tab 键。

空格用于分隔不同的编程元素。空格可以让运算待、数值、注释、参数等各种编
程元素之间错落有致，方便快速定位。空格的使用有如下约定：
1. 任何二目、三目运算符左右两边都必须加一个空格。
2. 注释的双斜线与注释内容之间有且仅有一个空格。
3. 方法参数在定义和传入时，多个参数逗号后边必须加空格。
4. 没有必要增加若干空格使变量的赋值等号与上一行对应位置的等号对齐。
5. 如果是大括号内为空，则简洁的写成{} 即可，大括号中间无须换行和空格。
6. 左右小括号与括号内部的相邻字符之间不要出现空格。
7. 左大括号前需要加空格。

空行用来分隔功能相似、逻辑内聚、意思相近的代码片段，使得程序布局更加清晰。在浏览代码时，空行可以起到自然停顿的作用，提升阅读代码的体验。哪些地方需要空行呢？在方法定义之后、属性定义与方法之间、不同逻辑、不同语义、不同业务的代码之间都需要通过空行来分隔。

#### 换行与高度

代码中需要限定每行的字符个数，以便适配显示器的宽度，以及方便CodeReview 时进行 diff 比对。对于无节制的行数字符，需要不断地拉取左右滚动条或者键盘移动光标，那是多么差的体验。因此 约定单行字符数不超过 120 个，超出则需要换行，换行时遵循如下原则：
1. 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。
2. 运算符与下文一起换行。
3. 方法调用的点符号与下文一起换行。
4. 方法调用中的多个参数需要换行时，在逗号后换行。
5. 在括号前不要换行。

除注释之外，方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。为什么是 80 行？心理学认为人对事物的印象通常不能超过 3 这个魔法数，三屏是人类短期记忆的极限，而 80 行在一般显示器上是两屏半的代码量。另外，通过对阿里代码抽样调查显示 只有不到 5% 的方法才会超过 80 而这些方法通常都有明显的优化空间。

#### 控制语句

控制语句是底层机器码跳转指令的实现。方法内部的跳转控制主要由条件判断语句和循环语句实现。跳转能力使程序能够处理复杂逻辑，具备像人一样的判断能力和记忆回溯能力。循环严格意义上也是一种跳转。

控制语句是最容易出现 Bug 的地方，所以特别需要代码风格的约束，而不是天
马行空地乱跳。控制语句必须遵循如下约定：
1. 在 if、else、for、while、do-while 等语句中必须使用大括号。即使只有一行代码也需要加上大括号。
2. 在条件表达式中不允许有赋值操作，也不允许在判断表达式中出现复杂的逻辑组合。有些控制语句的表达式逻辑相当复杂，与、或、取反混合运算甚至穿插了赋值操作，理解成本非常高，甚至会产生误解。要解决这个问题，有一个非常简单的办法：**将复杂的逻辑运算赋值给一个具有业务含义的布尔变量**。
3. 多层嵌套不能超过3层。多层嵌套在哪里都不受欢迎，是因为条件判断和分支逻辑数量呈指数关系。如果非得使用多层嵌套，请使用状态设计模式。对于超过 3 层的 if-else 的逻辑判断代码，可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：

   ![1566100919498](E:\git_repo\Hao_Learn\2019\8\img\1566100919498.png)
4. 避免采用取反逻辑符。取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。

## 3.3代码注释

#### 注释三要素
注释要求能够准确反映设计思想和代码逻辑；能够描述业务含义使其他工程师能迅速了解背景知识。书写注释要满足优雅注释三要素：
1. Nothing is strange
	完全没有注释的大段代码对于阅读者来说形同天书。注释是给自己看的，即使离写完代码很长时间，也能清晰地理解当时的思路，注释也是给维护者看的，使其能够快速理解代码逻辑。
2. Less is more 
	从代码可读性及维护成本方面来讲，代码中的注释，定是精华中的精华。
	首先，真正好的代码是自解释的，准确的变量命名加上合理的代码逻辑，无须过多的文字说明就足以让其他工程师理解代码的功能。如果代码需要大量的注释来说明解释，那么工程师应该思考是否可以优化代码表现力。其次，泛滥的注释不但不能帮助工程师理解代码，而且会影响代码的可读性，甚至会增加程序的维护成本。
3. Advance with the times
	与时俱进的重要性对于开发工程师来说是不言而喻的。针对一段有注释的代码，如果程序员修改了代码逻辑，但是没有修改注释，就会导致注释无法跟随代码前进的脚步，误导后续开发者。因此，任何对代码的修改，都应该同时修改注释。
	
#### 注释格式

1. Javadoc 规范
	类、类属性和类方法的注释必须遵循 Javadoc 规范，使用文档注释`/** *`的格式。特别强调对枚举的注释是必需的。每句实在太特殊了，它的代码极为稳定。如果它的定义和使用出现错误，通常影响较大。
2. 简单注释
	包括单行注释和多行注释。特别强调此类注释不允许写在代码后方，必须写在代码上方，这是为了避免注释的参差不齐，导致代码版式混乱。双画线注释往往使用在方法内部，此时的注释是提供给程序开发者、维护者和关注方法细节的调用者查看的。
	

注释的作用更应该是画龙点睛的，通常添加在非常必要的地方，例如复杂算法或需要警示的特殊业务场景等。

# 第4章 走进JVM

## 4.1 字节码

Java 所有的指令有 200 个左右，一个字节 (8 位) 可以存储 256 种不同的指令信息，一个这样的字节称为字节码 (Bytecode) 。在代码的执行过程中， JVM 将字节码解释执行，屏蔽对底层操作系统的依赖；JVM 也可以将字节码编译执行，如果是热点代码，会通过 JIT 动态地编译为机器码，提高执行效率。

![1566102418401](E:\git_repo\Hao_Learn\2019\8\img\1566102418401.png)

起始的 4个字节非常特殊，即绿色框的 cafe babe 是 Gosling 定义的 一个魔法数，意思是 Coffee Baby ，其十进制值为 3405691582 。它的作用是：标志该文件是一个 Java 类文件，如果没有识别到该标志，说明该文件不是 Java 类文件或者文件已受损，无法进行加载。而红色框代表当前版本号， 0x37 的十进制为 55 ，是 JDK11 的内部版本号。

纯数字的字节码阅读起来像天书一样难，当初汇编语言为了改进机器语言，使用助记符来替代对应的数字指令。JVM在字节码上也设计了一套操作码助记符，使用特殊单词来标记这些数字。

字节码主要指令如下：
1. 加载或存储指令
	在某个栈帧中，通过指令操作数据在虚拟机栈的局部变量表与操作栈之间来回传输，常见指令如下。
    - 将局部变量加载到操作栈中。如ILOAD（将 int 类型的局部变量压入栈）和   ALOAD （将对象引用的局部变量压入栈）等。
    - 从操作栈顶存储到局部标量表。 ISTORE、 ASTORE等。
    - 将常量加载到操作栈顶 ，这是极为高频使用的指令。 ICONST, BIPUSH SIPUSH LDC 等。
    	- ICONST 加载的是`-1 ~ 5`的数（ICONST 与 BIPUSH 的加载界限， 在`-1 ~ 5`之外的数字使用 BIPUSH 指令加载）。
    	- BIPUSH ，即 Byte Immediate PUSH ，加载`-128 ~ 127` 之间的数。
    	- SIPUSH ，即Short Immediate PUSH，加载`-32768 ~ 32767` 之间的数。
    	- LDC ，即 Load Constant，在`-2147483648 ~ 2147483647` 或者是字符串时，JVM 采用 LDC 指令压入枝中。
2. 运算指令
	对两个操作栈帧上的值进行运算，并把结果写入操作栈顶，如 IADD、IMUL 等。
3. 类型转换指令
	显式转换两种不同的数值类型。如 I2L 、D2F 等。
4. 对象创建与访问指令
	根据类进行对象的创建、初始化、方法调用相关指令，常见指令如下：
	- 创建对象指令。如NEW、NEWARRAY等。
	- 访问属性指令。如GETFIELD、PUTFIELD、GETSTATIC等。
	- 检查实例类型指令。如 INSTANCEOF、CHECKCAST等。
5. 操作栈管理指令
	JVM提供了直接控制操作栈的指令，常见指令如下：
	- 出栈操作。如POP即一个元素，POP2即两个元素。
	- 复制栈顶元素并压入栈。如DUP。
6. 方法调用与返回指令
	常见指令如下：
	- INVOKEVIRTUAL ：调用对象的实例方法。
	- INVOKESPECIAL ：调用实例初始化方法、私有方法、父类方法等。
	- INVOKESTATIC ：调用类静态方法。
	- RETURN：返回 VOID 类型。
7. 同步指令
	JVM 使用方法结构中的 ACC_SYNCHRONIZED 标志同步方法，指令集中有MONITORENTER 和 MONITOREXIT 支持 synchronized 语义。

除字节码指令外，还包含一些额外信息。例如， LINENUMBER 存储了字节码与源码行号的对应关系，方便调试的时候正确地定位到代码的所在行；LOCALVARIABLE 存储当前方法中使用到的局部变量表。

![1566105302731](E:\git_repo\Hao_Learn\2019\8\img\1566105302731.png)

词法解析是通过空格分隔出单词、操作符、控制符等信息，将其形成 token 信息流，传递给语法解析器；在语法解析时，把词法解析得到的 token 信息流按照 Java 语法规则组装成一棵语法树，如图 4-2 虚线框所示；在语义分析阶段，需要检查关键字的使用是否合理、类型是否匹配、作用域是否正确等；当语义分析完成之后，即可生成字节码。

字节码必须通过类加载过程加载到 JVM 环境后，才可以执行。执行有三种模式第一，解释执行；第二， JIT 编译执行；第三，JIT 编译与解释混合执行（主流JVM 默认执行模式）。
混合执行模式的优势在于解释器在启动时先解释执行，省去编译时间。随着时间推进 JVM 通过热点代码统计分析 ，识别高频的方法调用、循环体、公共模块等，基于强大的 JlT 动态编译技术，将热点代码转换成机器码，直接交给 CPU执行。 JIT 的作用是将 Java 字节码动态地编译成可以直接发送给处理器指令执行的机器码。

![1566107111781](E:\git_repo\Hao_Learn\2019\8\img\1566107111781.png)

注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态（刚启动时 ），如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。

在生产环境发布过程中 ，以分批的方式进行发布 ，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8 。

## 4.2 类加载过程

在冯 · 诺依曼定义的计算机模型中，任何程序都需要加载到内存才能与 CPU 进行交流。字节码 .class 文件同样需要加载到内存中，才可以实例化类。
ClassLoader 正是准备粮草的先行军，它的使命就是提前加载 .class 类文件到内存中。在加载类时，使用的是 Parents Delegation Model ，译为`双亲委派模型`，这个译名有些不妥。如果意译的话，则译作 `溯源委派加载模型`更加贴切。
Java 的类加载器是一个运行时核心基础设施模块，主要是在启动之初进行类的 Load、 Link、 Init，即加载、链接、初始化。
第一步，Load 阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验 cafe babe 魔法数、常量池、文件长度、是否有父类等，然后创建对应类的 java.Jang.Class 实例。
第二步，Link 阶段包括验证、准备、解析三个步骤。验证是更详细的校验，比如 final 是否合规、类型是否正确、静态变量是否合理等；准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。
第三步，Init 阶段执行类构造器＜clinit> 方法，如果赋值运算是通过其他类的静
态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。

![1566107945279](E:\git_repo\Hao_Learn\2019\8\img\1566107945279.png)

类加载是一个将 .class 字节码文件实例化成 Class 对象并进行相关初始化的过程。在这个过程中， JVM 会初始化继承树上还没有被初始化过的所有父类，并且会执行这个链路上所有未执行过的静态代码块、静态变量赋值语旬等。某些类在使用时，也可以按需由类加载器进行加载。

全小写的 class 是关键字，用来定义类，而首字母大写的 Class ，它是所有 class 的类。

![1566108418725](E:\git_repo\Hao_Learn\2019\8\img\1566108418725.png)

- 第 1 处说明：Class 类下的 newInstance() 在JDK9 中已经置为过时，应使用`getDeclaredConstructor().newlnstance()`的方式。这里着重说明一下 new 与 new Instance 的区别。 new 是强类型校验，可以调用任何构造方法，在使用 new 操作的时候，这个类可以没有被加载过。而 Class 类下的 newInstance 是弱类型，只能调用无参数构造方法，如果没有默认构造方法，就抛 InstantiationException 异常；如果此构造方法没有权限访问，则抛出
IllegalAccessException 异常。 Java 通过类加载器把类的实现与类的定义进行
解耦，所以是实现面向接口编程、依赖倒置的必然选择。
- 第 3 处说明：private 成员在类外是否可以修改？通过 setAccessible(true) 操作，即可使用大写 Class 类的 set 方法修改其值。如果没有这一步，则抛出如下异常：

![1566108751186](E:\git_repo\Hao_Learn\2019\8\img\1566108751186.png)

类加载器是如何定位到具体的类文件并读取的呢？类加载器类似于原始部落结构 存在权力等级制度。最高的一层是家族中威望最高的 Bootstrap ，它是在 JVM 启动时创建的， 通常由与操作系统相关的本地代码实现，是最根基的类加载器，负责装载最核心的 Java类， 比如 0bject、System、String 等；第二层是在 JDK9 版本中，称为 Platform ClassLoader ，即平台类加载器，用以加载一些扩展的系统类，比如 XML、加密、压缩相关的功能类等，而 JDK9 之前的加载器是Extension ClassLoader ；第三层是 Application ClassLoader 的应用类加载器，主要是加载用户定义的 CLASSPATH 路径下的类。第二、三层类加载器为Java 语言实现，用户也可以自定义类加载器。
```Java
// 正在使用的类加载器：jdk.internal.loader.ClassLoaders$AppClassLoad@69d0a
ClassLoader c = TestWhoLoad.class.getClassLoader();
// AppClassLoader 的父加载器是PlatformClassLoader
ClassLoader c1 = c.getParent();
// PlatformClassLoader 的父加载器是 Bootstarp。它是用c++实现的，返回null
ClassLoader c2 = c1.getParent();
```
代码上方的注释内容为 JDK11 的执行结果。在 JDK8 环境中，执行结果如下：
```
sun.misc.Launcher\$AppClassLoader@14dad5dc
sun.misc.Launcher\$ExtClassLoader@6e0be858
null 
```

AppClassLoader 的 Parent 是 Bootstrap，它是通过 C/C＋＋ 实现的，并不存在于JVM 体系内 ，所以输出为 null，类加载器具有等级制度，但是并非继承关系，以组合的方式来复用父加载器的功能，这也符合组合优先原则。

![1566109712214](E:\git_repo\Hao_Learn\2019\8\img\1566109712214.png)

低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。如图 4-6 所示，左侧绿色箭头向上逐级询问是否已加载此类，直至 Bootstrap ClassLoader ，然后向下逐级尝试是否能够加载此类，如果都加载不了，则通知发起加载请求的当前类加载器 ，准予加载。在右侧的三个小标签里，列举了此层类加载器主要加载的代表性类库，事实上不止于此。通过如下代码可以查看 Bootstrap 所有已经加载的类库：
```Java
URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();
for (java.net.URL url : urLs) {
	System.out.println(url.toExternalForm());
}
```
执行结果如下：

![1566110245338](E:\git_repo\Hao_Learn\2019\8\img\1566110245338.png)

Bootstrap 加载的路径可以追加，不建议修改或删除原有加载路径。 在 JVM 中增加如下启动参数，则能通过 Class.forName 正常读取到指定类，说明此参数可以增加Bootstrap 的类加载路径：
`-Xbootclasspath/a:/Users/yangguanbao/book/easyCoding/byJdkl l/src 
`
如果想在启动时观察加载了哪个 jar 包中的哪个类，可以增加 
`-XX:+TraceClassLoading`参数，此参数在解决类冲突时非常实用，毕竟不同的 JVM 环境对于加载类的顺序并非是一致的。有时想观察特定类的加载上下文，由于加载的类数量众多 ，调试时很难捕捉到指定类的加载过程，这时可以使用条件断点功能。比如，想查看 HashMap 的加载过程，在 loadClass 处打个断点，并且在 condition 框内输入如图 4-7 所示条件。

![1566110604986](E:\git_repo\Hao_Learn\2019\8\img\1566110604986.png)

需要自定义类加载器的情况下：
1. 隔离加载类。 在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。
2. 修改类加载方式。类的加载模型并非强制， 除Bootstrap外， 其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载。
3. 扩展加载源。比如从数据库、网络 ，甚至是电视机机顶盒进行加载。
4. 防止源码泄露。Java 代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。

实现自定义类加载器的步骤：继承 ClassLoader ，重写 findClass() 方法，调用
defineClass() 方法。一个简单的类加载器实现的示例代码如下：

```Java
public class CustomClassLoader extends ClassLoader {
	@Override
	protected Class<?> findClass(String name) throws ClassNotFoundException {
		try {
			byte[] result = getClassFromCustomPath(name);
			if (result == null) {
				throw new FileNotFoundExceoption();
			} else {
				return defineClass(name, result, 0, result.length);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		throw new ClassNotFoundException(name);
	}

	private byte[] getClassFromCustomPath (String name) {
		//从自定义路径中加载指定类
	}
}

public static void main(String[] args) {
	CustomClassLoader customClassLoader = new CustomClassLoader();
	try {
		Class<?> clazz = Class.forName("One", true, customClassLoader);
		Object obj = clazz.newInstance();
		System.out.println(obj.getClass()
			.getClassLoader());
	} catch (Exception e) {
		e.printStackTrace();
	}
}
```
执行结果如下：`classloader.CustomClassLoader@5e481248 `

由于中间件一般都有自己的依赖 jar 包，在同一个工程内引用多个框架时，往往被迫进进类的仲裁。按某种规则 jar 包的版本被统一指定 ，导致某些类存在包路径、类名相同的情况，就会引起类冲突 ，导致应用程序出现异常。主流的容器类框架都会自定义类加载器，实现不同中间件之间的类隔离，有效避免了类冲突。

#### 4.3 内存布局

​        内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略 ，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。

![1566115381445](E:\git_repo\Hao_Learn\2019\8\img\1566115381445.png)

1. Heap（堆区）

​        Heap 是 OOM 故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用。通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间。堆的内存空间既可以固定大小，也可以在运行时动态地调整，通过如下参数设定初始值和最大值，比如 `-Xms256M -Xmxl024M` ，其中`-X`表示它是 JVM 运行参数， ms 是 memory start 的简称， mx 是 memory max 的简称，分别代表最小堆容量和最大容窑量。但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以在线上生产环境中 JVM 的 Xms 和 Xmx 设置成一样大小，避免在 GC 后调整堆大小时带来的额外压力。

​        堆分成两大块：新生代和老年代。对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。
​        新生代 = 1个 Eden 区＋Survivor 区。绝大部分对象在 Eden 区生成，当Eden 区装填满的时候，会触发 Young Garbage Collection ，即 YGC。垃圾回收的时候，在 Eden 区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到 Survivor 区，这个区真是名副其实的存在。Survivor 区分为 S0 和 S1 两块内存空间，送到哪块空间呢？每次 YGC 的时候， 将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果 YGC 要移送的对象大于 Survivor 区容量的上限 ，则直接移交给老年代。假如一些没有进取心的对象以为可以一直在新生代的 Survivor 区交换来交换去，那就错了。每个对象都有一个计数器，每次 YGC 都会加1。

​        `-XX:MaxTenuringThreshold` 参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为1 ，那么对象会从新生代的 Eden 区直接移至老年代。默认值是 15 ，可以在 Survivor 区交换 14 次之后，晋升至老年代。

![1566116425601](E:\git_repo\Hao_Learn\2019\8\img\1566116425601.png)	
	如果 Survivor 区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配，如果老年代也无法放下，则会触发 Full Garbage Collection，即FGC。如果依然无法放下， 则抛出 OOM。堆内存出现 OOM 的概率是所有内存耗尽异常中最高的。出错时的堆内信息对解决问题非常有帮助，所以给 JVM 设置运行参数 `-XX:+HeapDumpOnOutOfMemoryError` ，让 JVM 遇到 OOM 异常时能输出堆内信息，特别是对相隔数月才出现的 OOM 异常尤为重要。
	在不同的 JVM 实现及不同的回收机制中，堆内存的划分方式是不一样的。

2. Metaspace（元空间）

​         本书源码解析和示例代码基本采用 JDK11 版本， JVM 则为 Hotspot。早在 JDK8 版本中，元空间的前身 Perm 区已经被淘汰。在 JDK7 及之前的版本中，只有 Hotspot 才有 Perm 区，译为永久代，它在启动时固定大小，很难进行调优，并且 FGC 时会移动类元信息。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多的类，经常出现致命错误。

![1566117033363](E:\git_repo\Hao_Learn\2019\8\img\1566117033363.png)

​        为了解决该问题，需要设定运行参数 `-XX:MaxPermSize = 1280m`，如果部署到新机器上，往往会因为 JVM 参数没有修改导致故障再现。不熟悉此应用的人排查问题时往往苦不堪言，除此之外，永久代在垃圾回收过程中还存在诸多问题。所以， JDK8 使用元空间替换永久代。在 JDK8 及以上版本中，设定MaxPermSize数， JVM 在启动时并不会报锚，但是会提示：
`Java HotSpot 64Bit Server VM warning: ignoring option MaxPem1Size=2560m; support was removed in 8.0`

​        区别于永久代，元空间在本地内存中分配。在 JDK8 里，Perm 区中的所有内容中，字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间内。

3. JVM Stack（虚拟机栈）

​        栈（Stack ）是一个先进后出的数据结构，就像子弹的弹夹，最后压入的子弹先发射，压在底部的子弹最后发射，撞针只能访问位于顶部的那一颗子弹。
​        相对于基于寄存器的运行环境来说，JVM是基于栈结构的运行环境。栈结构移植性更好，可控性更强。JVM中的虚拟机栈是描述 Java 方法执行的内存区域，它是线程私有的。栈中的元素用于支持虚拟机进行方法调用。每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。在活动线程中，只有位于栈顶的帧才是有效的，称为当前枝帧，正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。

![1566118162183](E:\git_repo\Hao_Learn\2019\8\img\1566118162183.png)

​        虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。栈帧在整个 JVM 体系中的地位颇高，包括局部变量表、操作栈、动态连接、方法返回地址等。

- **局部变量表**是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化。如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。字节码指令中的 STORE 指令可以将操作栈中计算完成的局部变量写回局部变量表的存储空间内。

- **操作栈**是一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中，下面用一段简单的代码说明操作栈与局部变量表的交互：

![1566119766352](E:\git_repo\Hao_Learn\2019\8\img\1566119766352.png)

第 1 处说明：局部变量表就像一个中药柜，里面有很多抽屉，依次编号为 0, 1, 2, 3, ...  , n ，字节码指令 ISTORE_1 就是打开 1号抽屉，把栈顶中的数 13 存进去。栈是一个很深的竖桶，任何时候只能对桶口元素进行操作，所以数据只能在栈顶进行存取。某些指令可以直接在抽屉里进行，比如 iinc 指令，直接对抽屉里的数值进行＋1操作。程序员面试过程中， 常见的 i++ 和 ++i 的区别，可以从字节码上对比出来，如表 4-1 所示。

![1566120192626](E:\git_repo\Hao_Learn\2019\8\img\1566120192626.png)

在表 4-1 左列中， iload_1 从局部变量表的第 1 号抽屉里取出一个数 ，压入栈顶，下一步直接在抽屉里实现 +1 的操作， 而这个操作对栈顶元素的值没有影响 。所以 istore_2 只是把栈顶元素赋值给 a；表格右列，先在第 1 号抽屉里执行 +1 操作，然后通过 iload_1 把第 1 号抽屉里的数压入栈顶， 所以 istore_2 存入的是 +1 之后的值。
这里延伸一个信息 ，i++ 并非原子操作。即使通过 volatile 关键字进行修饰，多个线程同时写的话，也会产生数据互相覆盖的问题。

- 每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的**动态连接**。

- 方法执行时有两种退出情况：第一，正常退出，即正常执行到任何方法的返回字节码指令，如RETURN、IRETURN、ARETURN 等；第二， 异常退出。无论何种退出情况，都将返回至方法当前被调用的位置。 方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：
	- 返回值压入上层调用栈帧。
	- 异常信息抛给能够处理的栈帧。
	- PC 计数器指向方法调用后的下一条指令。

4. Native Method Stacks （本地方法栈）
	本地方法栈（ Native Method Stack ）在 JVM 内存布局中，也是线程对象私有的，但是虚拟机栈 “主内”， 而本地方法栈 “主外”。这个“内外” 是针对 JVM 来说的，本地方法栈为 Native 方法服务。线程开始调用本地方法时，会进入一个不再受 JVM 约束的世界。本地方法可以通过 JNI ( Java Native Interface）来访问虚拟机运行时的数据区 ，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对于内存不足的情况，本地方法栈还是会抛出 `native heap OutOfMemory`
	重点说一下 JNI 类本地方法。最著名的本地方法应该是System.currentTimeMillis() , JNI 使 Java 深度使用操作系统的特性功能，复用非 Java 代码。但是在项目过程中，如果大量使用其他语言来实现 JNI 就会丧失跨平台特性，威胁到程序运行的稳定性。假如需要与本地代码交互，就可以用中间标准框架进行解耦，这样即使本地方法崩溃也不至于影响到 JVM 的稳定。当然，如果要求极高的执行效率、偏底层的跨进程操作等，可以考虑设计为 JNI 调用方式。

5. Program Counter Register（程序计数寄存器）

	在程序计数寄存器（Program Counter Register, PC）中， Register 的命名源于 CPU 的寄存器， CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。
	

最后，从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本
地方法栈、程序计数器是线程内部私有的。

![1566121254574](E:\git_repo\Hao_Learn\2019\8\img\1566121254574.png)

#### 4.4 对象实例化

Java 是面向对象的静态强类型语言，声明并创建对象的代码很常见，根据某个类声明一个引用变量指向被创建的对象，并使用此引用变量操作该对象。在实例化对象的过程中，JVM 中发生了什么化学反应呢？



1. 下面从最简单的 `Object ref = new Object()` 代码进行分析，利用 `javap -verbose -p` 命令查看对象创建的字节码如下：

![1566123921007](E:\git_repo\Hao_Learn\2019\8\img\1566123921007.png)

- NEW：如果找不到 Class 对象，则进行类加载。加载成功后，则在堆中分配内存，从 Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用 4 个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。

- DUP：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果＜init> 方法有参数，还需要把参数压入操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。
- INVOKESPECIAL：调用对象实例方法，通过栈顶的引用变量调用`＜init>` 方法。`<clinit>` 是类初始化时执行的方法 而`＜init>` 是对象初始化时执行的方法。

2. 前面所述的是从字节码的角度看待对象的创建过程，现在从执行步骤的角度来分析：

- 确认类元信息是否存在。当 JVM 接收到 new 指令时，首先在 metaspace 内检查需要创建的类元信息是否存在。若不存在，那么在双亲委派模式下，使用当前类加载器以ClassLoader＋包名＋类名为 Key 进行查找对应的 .class 文件。如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 类对象。
- 分配对象内存。首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4个字节大小，接着在堆中划分一块内存给新对象。在分配内存空间时，需要进行同步操作，比如采用 CAS ( Compare And Swap ）失败重试、区域加锁等方式保证分配操作的原子性。
- 设定默认值。成员变量值都需要设定为默认值，即各种不同形式的零值。
- 设置对象头。设置新对象的哈希码、 GC 信息、锁信息、对象所属的类元信息等。这个过程的具体设置方式取决于 JVM 实现。
- 执行 init 方法。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

## 4.5 垃圾回收

Java 会对内存进行自动分配与回收管理，使上层业务更加安全，方便地使用内存实现程序逻辑。在不同的 JVM 实现及不同的回收机制中，堆内存的划分方式是不一样的。这里简要介绍垃圾回收（ Garbage Collection, GC ）。垃圾回收的主要目的是清除不再使用的对象，自动释放内存。

GC 如何判断对象是否可以被回收的呢？为了判断对象是否存活，JVM 引入了GC Roots 。如果 一个对象与 GC Roots 之间没有直接或间接的引用关系，比如某个失去任何引用的对象，或者两个互相环岛状循环引用的对象等，判决这些对象“死缓”，是可以被回收的。什么对象可以作为 GC Roots 呢？比如类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象等。

有了判断对象是否存活的标准后，再了解一下垃圾固收的相关算法。最基础的为`标记－清除算法`，该算法会从每个 GC Roots 出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。但是这种算法会带来大量的空间碎片，导致需要分配一个较大连续空间时容易触发 FGC。为了解决这个问题，又提出了`标记－整理算法`，该算法类似计算机的磁盘整理，首先会从 GC Roots 出发标记存活的对象，然后将存活对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片的问题。`Mark-Copy 算法`，为了能够并行地标记和整理将空间分为两块，每次只激活其中一块，垃圾回收时只需把存活的对象复制到另一块未激活空间上，将未激活空间标记为己激活，将己激活空间标记为未激活，然后清除原空间中的原对象。堆内存空间分为较大的Eden 和两块较小 Survivor ，每次只使用 Eden 和 Survivor 的一块。这种情形下的`Mark-Copy 算法`减少了内存空间的浪费。`Mark-Copy 算法`现作为主流的 YGC 算法进行新生代的垃圾回收。

垃圾回收器（ Garbage Collector ）是实现垃圾回收算法并应用在 JVM 环境中的内存管理模块。当前实现的垃圾回收器有数十种，本节只介绍 Serial 、CMS、G1三种。

Serial 回收器是一个主要应用于 YGC 的垃圾回收器，采用串行单线程的方式完 GC 任务，其中` Stop The World `简称 STW ，即垃圾回收的某个阶段会暂停整个应用程序的执行。 FGC 的时间相对较长，频繁 FGC 会严重影响应用程序的性能。主要流程如图 4-13 所示。

![1566125416917](E:\git_repo\Hao_Learn\2019\8\img\1566125416917.png)

CMS 回收器（ Concurrent Mark Sweep Collector ）是回收停顿时间比较短、目前比较常用的垃圾回收器。它通过初始标记（ Initial Mark ）、并发标记（ Concurrent Mark ）、重新标记（ Remark ） 、并发清除（ Concurrent Sweep）四个步骤完成垃圾回收工作。第 1、3 步的初始标记和重新标记阶段依然会引发 STW ，而第 2、4 步的并发标记和并发清除两个阶段可以和应用程序并发执行，也是比较耗时的操作，但并不影响应用程序的正常执行。由于 CMS 采用的是 `标记－清除算法`，因此产生大量的空间碎片。为了解决这个问题， CMS 可以通过配置 `-XX:+UseCMSCompactAtFullCollection` 参数，强制 JVM 在 FGC 完成后对老年代进行压缩， 执行一次空间碎片整理，但是空间碎片整理阶段也会引发 STW 。为了减少 STW 次数， CMS 还可以通过配置
`-XX:+CMSFullGCsBeforeCompaction=n` 参数，在执行了 n次 FGC 后， JVM 再在老年代执行空间碎片整理。

Hotspot 在 JDK7 推出了新一代 G1 ( Garbage-First Garbage Collector）垃圾回收，通过`-XX:+UseG1GC` 参数启用。和 CMS 相比， G1具备压缩功能，能避免碎片问题，G1 的暂停时间更加可控。性能总体还是非常不错的，简要结构如图 4-14 所示。

![1566125868295](E:\git_repo\Hao_Learn\2019\8\img\1566125868295.png)

G1 将 Java 堆空间分割成了若干相同大小的区域，即 region ，包括 Eden、Survivor、Old、Humongous 四种类型。其中， Humongous 是特殊的 Old 类型，专门放置大型对象。这样的划分方式意味着不需要一个连续的内存空间管理对象。G1将空间分为多个区域，优先回收垃圾最多的区域。 G1 采用的是`Mark-Copy 算法`，有非常好的空间整合能力，不会产生大量的空间碎片。G1 的一大优势在于可预测的停顿时间，能够尽可能快地在指定时间内完成垃圾回收任务。在 JDK11中，已经将 G1 设为默认垃圾回收器，通过 jstat 命令可以查看垃圾回收情况，如图 4-15 所示，在 YGC 时 S0/S1 并不会交换。

![1566126093204](E:\git_repo\Hao_Learn\2019\8\img\1566126093204.png)

S0/S1 的功能由 G1 中的 Survivor region 来承载。通过 GC 日志可以观察到完整的垃圾回收过程如下，其中就有 Survivor regions 的区域从 0个到 1个。

![1566126128284](E:\git_repo\Hao_Learn\2019\8\img\1566126128284.png)

红色标识的为 G1 中的四种 region 都处于 Heap 中。G1 执行时使用 4个 worker并发执行，在初始标记时，还是会触发 STW ，如第一步所示的 Pause。


# 第五章 异常与日志

如果异常在当前方法的处理能力范围之内且没有必要对外透出，那么就直接捕获异常并做相应处理；否则向上抛出，由上层方法或者框架来处理。

但是无论采用哪种方式处理异常，都严禁捕获异常后什么都不做或打印一行日志了事。如果在方法内部处理异常，需要根据不同的业务场景进行定制处理，如重试、回滚等操作。如果向上抛出异常，需要在异常对象中添加上下文参数、局部变量、运行环境等信息，这样有利于排查问题。

![1566197555436](E:\git_repo\Hao_Learn\2019\8\img\1566197555436.png)

在与数据库交互时可能会发生网络连接不通、数据库锁超时、插入数据失败等异常，向上归一化为 DAOException 异常。

## 5.1 异常分类

JDK 中定义了一套完整的异常机制，所有异常都是 Throwable 的子类，分为 Error（致命异常）和 Exception（非致命异常）。 Error 是一种非常特殊的异常类型，它的出现标识着系统发生了不可控的错误，例如 StackOverflowError 、OutOfMemoryError 。针对此类错误，程序无法处理，只能人工介入。 Exception 又分 checked 异常 （受检异常）和 unchecked 异常（非受检异常）。

checked 异常是需要在代码中显式处理的异常，否则会编译出错。常见的 checked 异常包括 JDK 中定义的 SQLException、ClassNotFoundException 等。

check 异常可以进一步细分为两类：

- 无能为力、引起注意型。针对此类异常，程序无法处理，如字段超长等导致SQLException，即使做再多的重试对解决异常也没有任何帮助，一般处理此类异常的做法是完整地保存异常现场，供开发工程师介入解决。
- 力所能及、坦然处置型。如发生未授权异常 （UnAuthorizedException），程序可跳转至权限申请页面。

在Exception中，unchecked 异常是运行时异常，它们都继承自 RuntimeException ，不需要程序进行显式的捕捉和处理，unchecked 异常可以进一步细分为 3 类：

- 可预测异常（Predicted Exception）：常见的可预测异常包括IndexOutOtBoundsException，NullPointerException等，基于对代码的性能和稳定性要求，此类异常不应该被产生或者抛出，而应该提前做好边界检查、空指针判断等处理。显式的声明或者捕获此类异常会对程序的可读性和运行效率产生很大影响。
- 需捕捉异常（Caution Exception），例如在使用 Dubbo 框架进行 RPC 调用时产生的远程服务超时异常 DubboTimeoutException，此类异常是客户端必须显式处理的异常，不能因服务端的异常导致客户端不可用，此时处理方案可以是重试或者降级处理等。
- 可透出异常（Ignored Exception），主要是指框架或系统产生的且会自行处理的异常，而程序无须关心。例如针对 Spring 框架中抛出的 NoSuchRequestHandlingMethodException 异常， Spring 框架会自己完成异常的处理，默认将自身抛出的异常自动映射到合适的状态码，比如启动防护机制跳转到 404 页面。

综上所述，异常分类结构如图 5-1 所示：

![1566198421276](E:\git_repo\Hao_Learn\2019\8\img\1566198421276.png)

## 5.2 try代码块

finally 代码块是必选执行的代码块，不管是否有异常产生，即使发生`OutOfMemoryError`也会执行，通常用于处理善后清理工作。如果 finally 代码块没有执行，那么有三种可能：
1. 没有进入 try 代码块。
2. 进入 try 代码块，但是代码运行中出现了死循环或死锁状态。
3. 进入 try 代码块，但是执行了 System.exit() 操作。

注意， finally 是在 return 表达式运行后执行的，此时将要 return 的结果已经被暂存起来，待finally 代码块执行结束后再将之前暂存的结果返回，但如果 finally 中有 return ，那么会返回finally 中的值。

finally 代码块的职责不在于对变量进行赋值等操作，而是清理资源、释放连接、关闭管道流等操作，例如 Lock、ThreadLocal、InputStream 等这些需要进行强制释放和清除的对象都得在finally 代码块中进行显式的清理，避免产生内存泄漏，或者资源消耗。

分析 try 代码块与锁的关系：
lock 方法可能会抛出 unchecked 异常，如果放在 try 代码块中，必然触发 finally 中的 unlock 方法执行。对未加锁的对象解锁会抛出 unchecked 异常，如 IllegalMonitorStateException 虽然是因为加锁失败而造成程序中断的，但是真正加锁失败的原因可能会被后者覆盖。所以在 try 代码块之前调用lock() 方法，避免由于加锁失败导致 finally 调用 unlock() 抛出异常。

## 5.3 异常的抛与接

我们要使捕获的异常与被抛出的异常是完全匹配的，或者捕获的异常是被抛出异常的父类。

传递异常信息的方式是通过抛出异常对象，还是把异常信息转成信号量封装在特定对象中，这需要方法提供者和方法调用者之间达成契约，只有大家都照章办事，才不会产出误解。推荐对外提供的开放接口使用错误码；公司内部跨应用远程服务调用优先考虑使用 Result 对象来封装错误码、错误描述信息；而应用内部则推荐直接抛出异常对象。

如果使用抛异常的返回方式，一旦调用方没有捕获，就会产生运行时错误，导致程序中断；此外，如果抛出的异常中不添加栈信息，只是 new 自定义异常并加入自定义的错误信息，对于调用端解决问题的帮助不会太大；如果加了栈信息，在频繁调用出错的情况下，信息序列化和传输的性能损耗也是问题。所以推荐在远程服务调用中使用 Result 对象封装异常信息。

我们推荐方法的返回值可以为 null ，不强制返回空集合或者空对象等，但是必须添加注释充分说明什么情况下会返回 null 值。防止 NPE 一定是调用方的责任，需要调用方进行事先判断。

## 5.4 日志

记录应用系统日志主要有三个原因：记录操作轨迹、监控系统运行状况、回溯系统故障。

记录操作行为及操作轨迹数据，可以数据化地分析用户偏好，有助于优化业务逻辑，为用户提供个性化的服务。例如，通过 access.log 记录用户的操作频度和跳转链接，有助于分析用户的后续行为。

全面有效的日志系统有助于建立完善的应用监控体系，由此工程师可以实时监控系统运行状况，及时预警，避免故障发生。监控系统运行状况，是指对服务器使用状态，如内存、 CPU 等使用情况；应用运行情况，如响应时间，QPS 等交互状态；应用错误信息，如空指针、 SQL 异常等的监控。

当系统发生线上问题时，完整的现场日志有助于工程师通过回溯系统故障快速定位问题。

#### 日志规范

推荐的日志文件命名方式为 `appName_logType_logName.log`。其中 logType 为日志类型，推荐分类有 stats、monitor、visit 等；logName 为日志描述。这种命名的好处是通过文件名就可以知道日志文件属于什么应用，什么类型 ，什么目的，也有利于归类查找。

如果日志存储周期较短，如 7 天，那么针对有些具备以“周”为频次发生的异常就无法被发现，相反，若日志保存周期过长，又会对磁盘存储空间造成较大压力，产生不必要的资源消耗。因此综合两个方面考虑，代码规约推荐日志文件至少保存 7 天，可以根据日志文件的重要程度、
文件大小及磁盘空间再自行延长保存时间。

日志是有级别的。针对不同的场景，日志被分为五种不同的级别，按照重要程度由低到高排序：

- DEBUG 级别日志：记录对调试程序有帮助的信息。
- INFO 级别日志：用来记录程序运行现场，虽然此处并未发生错误，但是对排查其他错误具有指导意义。
- WARN 级别日志：也可以用来记录程序运行现场，但是更偏向于表明此处有出现潜在错误的可能。
- ERROR 级别日志：表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行。
- FATAL 级别日志：表明当前程序运行出现了严重的错误事件，并且将会导致应用程序中断。

1. 预先判断日志级别

对于 DEBUG 、INFO 级别的日志，必须使用条件输出或者使用占位符的方式打印。该约定综合考虑了程序的运行效率和日志打印需求。

![1566202502986](E:\git_repo\Hao_Learn\2019\8\img\1566202502986.png)

2. 避免无效日志打印

生产环境禁止输出 DEBUG 日志且有选择地输出 INFO 日志。
使用 INFO、 WARN 级别来记录业务行为信息时，一定要控制日志输出量，以免磁盘空间不足。同时要为日志文件设置合理的生命周期，及时清理过期的日志。
避免重复打印，务必在日志配置文件中设置 `additiviity=false` ，示例如下：
`<loggername= "com.taobao.ecrm.member.config" additivity=” false" >`

3. 区别对待错误日志

ERROR 级别日志只记录系统逻辑错误、异常或者违反重要的业务规则，一旦出现就需要人为介入。其他错误都可以归为 WARN级别。

4. 保证记录内容完整

日志记录的内容包括现场上下文信息与异常堆栈信息，所以打印时需要注意以下两点：

- 记录异常时，一定要输出异常堆栈，例如：`logger.error("xxx"+e.getMessage(),e)`
- 日志中如果输出对象实例，要确保实例类重写了 toString ()，否则只会输出对象的 hashCode 值，没有实际意义。

综上所述，日志是一个系统必不可少的组成部分，但日志打印并非多多益善，过多的日志会降低系统性能，也不利于快速定位问题，所以记录日志时一定请思考三个问题： ①日志是否有人看； ②看到这条日志能做什么 ；③能不能提升问题排查效率。

#### 日志框架

日志框架分为三大部分，包括日志门面、日志适配器、日志库。利用门面设计模式，即Facade  来进行解耦，使日志使用变得更加简单。

![1566203205629](E:\git_repo\Hao_Learn\2019\8\img\1566203205629.png)

1. 日志门面

门面设计模式是面向对象设计模式中的一种，日志框架采用的就是这种模式，类似 JDBC 的设计理念。它只提供一套接口规范，自身不负责日志功能的实现，目的是让使用者不需要关注底层具体是哪个日志库来负责日志打印及具体的使用细节等。目前用得最为广泛的日志门面有两种： slf4j 和 commons-logging 。

2. 日志库

它具体实现了日志的相关功能，主流的日志库有三个，分别是 log4j、log-jdk、logback。最早 Java 要想记录日志只能通过 System.out 或 System. error 来完成，非常不方便。log4j 就是为了解决这一问题而提出的，它是最早诞生的日志库。接着 JDK 也在 1.4 版本引入了一个日志库 `java.util.logging.Logger`，简称 log-jdk。这样市面上就出现两种日志功能的实现，开发者在使用时需要关注所使用的日志库的具体细节。logback 是最晚出现的，它与 log4j 出自同一个作者，是log4j 的升级版且本身就实现了 slf4j 的接口。

3. 日志适配器

日志适配器分两种场景：

- 日志门面适配器，因为 slf4j 规范是后来提出的，在此之前的日志库是没有实现 slf4j 的接口的，例如 log4j；所以，在工程里要想使用 slf4j + log4j 的模式，就额外需要一个适配器（slf4j- log4j12）来解决接口不兼容的问题。
- 日志库适配器，在一些老的工程里，一开始为了开发简单而直接使用了日志库API来完成日志打印，随着时间的推移想将原来直接调用日志库的模式改为业界标准的门面模式（例如 slf4j+logback组合），但老工程代码里打印日志的地方太多了，难以改动，所以需要一个适配器来完成从旧日志库的 API 到 slf4j 的路由，这样在不改动原有代码的情况下也能使用 slf4j 来统一管理日志，而且后续自由替换具体日志库也不成问题。

以 Maven工程为例介绍如何在工程里进行日志集成。
如果是新工程，则推荐使用 slf4j + logback 模式。因为 logback 自身实现了 slf4j的接口，无须额外引入适配器，另外 logback 是 log4j 的升级版，具备比 log4j 更多的优点，可通过如下配置进行集成：

```xml
<dependency>
    <groupid>org.slf4]</groupid>
    <artifactid>slf4j-api</artifactid>
    <version>${slf4j-api.version}</version>
</dependency>
<dependency>
    <groupid>ch.qos.logback</groupid>
    <artifactid>logback-classic</artifactid>
    <version>${logback-classic.version}</version>
</dependency>
<dependency>
    <groupid>ch.qos.logback</groupid>
    <artifactid>logback core</artifactid>
    <version>${logback-core.version}</version>
</dependency> 
```
再加上一个日志配置文件（如logback.xml、log4j.xml 等），并在工程启动时加载，然后就可以进行日志打印了，示例代码如下·

```Java
private static final Logger logger= LoggerFactory.getLogger(Abc.class); 
```

注意，logger 被定义为 static 变量，是因为这个 logger 与当前类绑定，避免每次 new 一个新对象，造成资源浪费，甚至引发 OutOfMernoryError 问题。

另外，在使用 slf4j＋日志库模式肘，要防止日志库冲突，一旦发生则可能会出现日志打印功能失效的问题。

# 第六章 数据结构与集合

## 6.1 数据结构

#### 数据结构定义

数据结构是指逻辑意义上的数据组织方式及其相应的处理方式。

1. 什么是逻辑意义？

数据结构的抽象表达非常丰富，而实际物理存储的方式相对单一。比如，二叉树在磁盘中的存储真的是树形排列吗？并非如此。树的存储可能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有 7 个节点的二叉树，第一个格子放根节点，第二个格子放左子树根节点；并且根据引用知道左叶子在后续的哪个格子里，第三个格子放右子树根节点，依此类推。此外，树的存储也可能是基于物理上的链式存储方式，这里不再详细展开。

2. 什么是数据组织方式？

逻辑意义上的组织方式有很多，比如树、图、队列、哈希等。树可以是二叉树、三叉树、 B+树等，图可以是有向图或无向图，队列 是先进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式。

3. 什么是数据处理方式？

在既定的数据组织方式上，以某种特定的算法实现数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性能差异。

#### 数据结构分类

数据结构是算法实现的基石，它是一种体现基础逻辑思维的内功心法，也是计算机从业人员能力图谱中的重要一项。如果完全不懂数据结构，很难写出优秀的代码。有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分为以下四类。

1. 线性结构

0 至 1个直接前继和直接后继。当线性结构非空时，有唯一的首元素和尾元素，除两者外，所有的元素都有唯一的直接前继和直接后继。线性结构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。栈是后进先出，即 Last In，First-Out ，简称 LIFO ；队列是先进先出，即 First-In，First-Out ，简称 FIFO 。

2. 树结构

0 至 1 个直接前继和 0 至 n 个直接后继（n 大于或等于 2）。树是一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定和均衡，在计算机领域中得到广泛应用。

3. 图结构

0 至 n 个直接前继和直接后继（n 大于或等于 2）。图结构包括简单图、多重图、有向图和无向图等。

4. 哈希结构

没有直接前继和直接后继。哈希结构通过某种特定的哈希函数将索引与存储的值关联起来，他是一种查找效率非常高的数据结构。

不同的数据组织方式和处理方式带来了一个新的问题：如何衡量数据处理的性能。

数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指标，反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算法性能的优劣与否。而这个量级通常用大写的 *O* 和一个函数描述，如 *O*(*n*^3^) 表示程序执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。从最好到最坏的常用算法复杂度排序如下：常数级 *O*(1) 、对数级 *O*(log*n*) 、线性级 *O*(*n*)  、线性对数级 *O*(*n*logn)  、平方级 *O*(*n*^2^)、立方级 *O*(*n*^3^) 、指数级 *O*(2^n^) 等。有人觉得在实际编程中没有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的急剧下降。

最后以 “猜数字” 为例进一步理解时间复杂度，主持人从`1 ~ 100` 的范围内任选一个数字，玩家随机猜一个数，如果没有猜中，主持人会提示猜大了还是猜小了，继续这样的循环 ，直到猜对为止。显而易见，如果要猜测，最多要猜 100 次，最少只用猜 1 次。经验表明，玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模拟程序运行 1 亿次，完全随机的情况下，平均猜测的次数是 7.47 次， 近似二分法猜测的是 5.8 次，时间复杂度为 *O*(log*n*) 。

## 6.2 集合框架图

![1566207900950](E:\git_repo\Hao_Learn\2019\8\img\1566207900950.png)

在集合框架图中，红色代表接口，蓝色代表抽象类，绿色代表并发包中的类，灰色代表早期线程安全的类（基本已经弃用）。可以看到，与 Collection 相关的 4 条线分别是 List、Queue、Set、Map，它们的子类会映射到数据结构中的表、树、哈希等。对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。

#### List 集合

p165