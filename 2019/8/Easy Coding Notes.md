# 计算机基础

## 走进0与1的世界

#### 为何负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32 位）和长整型（64 位）数上，假如在整型数上移动的位数是32 位，**无论是否带符号位以及移动方向，均为本身**。因为移动的位数是个mod 32 的结果，即 `35 >> 1` 与 `35 >> 33` 是一样的结果。如果是长整型， mod 64，即 `35 << 1` 与`35 << 65`的结果是一样的。负数在无符号往右移动 63 位时，除最右边为1， 左边均为0，达到最小值1，如果 >>> 64，则为其原数值本身。

```java
public class Test{

	public static void main(String[] args) {
		int a = 35;
		int b = -35;

		System.out.println("==========正数============");
		System.out.println(a >>> 1);

		System.out.println(a >>> 27);
		System.out.println(a >>> 28);
		System.out.println(a >>> 29);
		System.out.println(a >>> 30);
		System.out.println(a >>> 31);
		System.out.println(a >>> 32);
		System.out.println(a >>> 33);
		System.out.println("==========负数============");
		System.out.println(b >>> 1);

		System.out.println(b >>> 27);
		System.out.println(b >>> 28);
		System.out.println(b >>> 29);
		System.out.println(b >>> 30);
		System.out.println(b >>> 31);
		System.out.println(b >>> 32);
		System.out.println(b >>> 33);
	}
	
}
```

结果：

```
==========正数============
17	//1
0	//27
0
0
0
0	//31
35	//32
17
==========负数============
2147483630	//1
31	//27
15
7
3
1	//31
-35	//32
2147483630
```

#### 异或运算 ^

异或运算没有短路功能，一般在哈希算法中用于离散哈希值，对应的位上不一样才是1。



## 浮点数

#### 浮点数表示

当前业界流行的浮点数标准是 `IEEE754` ，该标准规定了4种浮点数类型：单精度、双精度、延伸单精度、延伸双精度。前两种类型是最常用的。

**浮点数无法表示零值。**

范围：

| 精度       | 字节数 | 正数取值范围             | 负数取值范围             |
| ---------- | ------ | ------------------------ | ------------------------ |
| 单精度类型 | 4      | `1.4e-45 至 3.4e+38`     | `-3.4e+38 至 -1.4e-45`   |
| 双精度类型 | 8      | `4.9e-324 至 1.798e+308` | `1.798e+308 至 4.9e-324` |

#### 阶码位

IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。

移码是将一个真值在数轴上正向平移一个偏移量之后得到的，即 [x]~移~ = x + 2^n-1^ （n为x的二进制位数，含符号位）。移码的几何意义是把真值映射到一个正数域，其特点是可以直观地反映两个真值的大小，即移码大的真值也大。

> 真值 = 阶码 - （2^n-1^ - 1）

#### 为什么偏移值为2^n-1^ - 1 而不是 2^n-1 呢？

因为8个二进制位能表示指数的取值范围为 [-128,127] ，现在将指数变成移码表示，即将区间 [-128,127] 正向平移到正数域，区间里的每个数都需要加上 128 ，从而得到阶码范围为[0,255 ] 。

由于计算机规定阶码全为 0 或全为 1 两种情况被当作特殊值处理（全 0 被认为是机器零，全 1 被认为是无穷大），去除这两个特殊值，阶码的取值范围变成了 [1,254] 。

如果偏移量不变仍为128 的话，则根据换算关系公式 [x]~阶~ = x + 128 得到指数的范围变成[-127,126]，指数最大只能取到 126 ，显然会缩小浮点数能表示的取值范围。

所以 IEEE754 标准规定单精度的阶码偏移量为 2^n-1^ - 1 （即 127 ），这样能表示的指数范围为[-126,127]，指数最大值能取到 127。

0**111-1111-0**111-1111-1111-1111-1111-1111

为了节约存储空间，将符合规格化位数的首个1省略，所以尾数表面上是23位，却表示了24位二进制数。

#### 加减运算
对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。

1. 零值检测。 检查参加运算的两个数中是否存在为 0 的数（ 0  在浮点数是一
种规定，即阶码与尾数全为 0 ），因为浮点数运算过程比较复杂，如果其中一个数为 0,可以直接得出结果。
2. 对阶操作。 通过比较阶码的大小判断小数点位置是否对齐。IEEE754 规定对阶的移动方向为向右移动，即选择阶码小的数进行操作。
3. 尾数求和。
4. 结果规格化。如果运算的结果仍然满足规格化形式，则无须处理，否则需要通过尾数位的向左或右移动调整达到规格化形式。尾数位向右移动称为右规，反之称为左规。
5. 结果舍入。在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃， 从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。

#### 浮点数使用
在使用浮点数时推荐使用**双精度**，使用单精度由于表示区间的限制 ，计算结果会出现微小的误差。
1. 在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储。
2. 在要求精确表示小数点 n 位的业务场景下，比如圆周率要求存储小数点后 1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推荐采用数组保存小数部分的数据。
3. 在比较浮点数时，由于存在误差，往往会出现意料之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。
4. 在数据库中保存小数时，推荐使用 `decimal` 类型，禁止使用 float 类型和 double 类型。因为这两种类型在存储的时候，存在精度损失的问题。

## 字符集与乱码
实现 Unicode 的编码格式有三种 UTF-8 UTF-16 UTF-32，UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为对Unicode 的压缩方式。根据二八原则，常用文字只占文字总数的 20% 左右。

在日常开发中，字符集如果不兼容则会造成乱码。

乱码的出现场景并不止于编码环境中，还有网页展示、文本转换、文件读取等。数据流从底层数据库到应用层，到Web 服务器，再到客户端显示，每位开发工程师都会碰到字符乱码的问题，排查起来是一个比较长的链路。

数据库是存储字符之源，在不同层次上都能够设置独立的字符集，如服务器级别、 schema 级别、表级别甚至列级别。为了减少麻烦，所有情况下的字符集设置最好是一致的。

## CPU与内存
越往 CPU 核心靠近，存储越贵，速度越快。越往下，存储越便宜、速度越慢，当然容量也会更大。
程序员们最害怕的 OOM（Out Of Memory）通常来源于由于不恰当的编码方式而导致内存的资源耗尽 ，虽然现代内存的容量已经今非昔比，但仍然是可以在秒级内耗尽所有内存资源的。
内存的抽象就是线性空间内的字节数组，通过下标访问某个特定位置的数据，比如 C 语言使用 malloc（） 进行内存的分配，然后使用指针进行内存的读与写；而以 Java 为代表的编程语言，内存就交给 JVM 进行自动分配与释放，这个过程
称为垃圾回收机制。虽然垃圾回收机制能为程序员减负，但如果不加节制的话，同样会耗尽内存资源。

## TCP / IP

#### 概述
TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协议／因特网互联协议，这个大家族里的其他知名协议还有 HTTP, HTTPS、 FTP、SMTP、UDP、 ARP、PPP、IEEE 802.x 等。它是当前流行的网络传输协议框架，从严格意义上讲它是一个协议族，因为 TCP、IP 是其中最为核心的协议，所以就把该协议族称为 TCP/IP 。
而另一个是耳熟能详的 ISO/OSI 的七层传输协议，其中 OSI( Open System Interconnection ）的出发点是想设计出计算机世界通用的网络通信基本框架，它已经被淘汰。
![1565492275741](E:\git_repo\Hao_Learn\2019\8\img\1565492275741.png)


- 链路层：单个0、1 是没有意义的，链路层以字节为单位把 0 与 1 进行分组，  定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。
![1565492513881](E:\git_repo\Hao_Learn\2019\8\img\1565492513881.png)
MAC 地址长 6个字节共 48 位，通常使用十六进制数表示。使用 ifconfig -a 命令即可看到 MAC 地址。MAC地址的前 24 位（3个字节）由管理机构统一分配，后24 位由厂商自己分配，保证网卡全球唯一。

- 网络层： 根据 IP 定义网络地址，区分网段。子网内根据ARP（Address Resolution Protocol，地址解析协议）进行 MAC 寻址，子网外进行路由转发数据包，这个数据包即 IP 数据包。
- 传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是 UDP和TCP。UDP 只是在 IP 数据包上增加端口等部分信息，是面向无连接的，是不可靠传输，多用于视频通信、电话会议等（即使少一帧数据也无妨）。与之相反的TCP 是面向连接的。所谓面向连接，是一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一条固定的通路承载着数据的可靠传输。
- 应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数
据。比如，E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是都能够读取邮件内容，是因为 SMTP （Simple Mail Transfer Protocol，简单邮件传输协议）就像传统的书信恪式一样，按规定填写邮编及收信人信息。

总结一下，程序在发送消息时，应用层按既定的协议打包数据，随后由传输层加
上双方的端口号 ，由网络层加上双方的 IP 地址，由链路层加上双方的 MAC 地址，并将数据拆分成数据帧，经过多个路由器和网关后，到达目标机器。简而言之，就是按**端口 -> IP 地址 -> MAC 地址 **这样的路径进行数据的封装和发送，解包的时候反过来操作即可

#### IP 协议

IP 是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP
首先规定出 IP 地址格式，该地址相当于在逻辑意义上进行了网段的划分，给每台计算机额外设置了一个唯一的详细地址。
IP 地址属于网络层，主要功能在 WLAN 内进行路由寻址，选择最佳路由。
![1565493293196](E:\git_repo\Hao_Learn\2019\8\img\1565493293196.png)
生存时间TTL（Time To Live），即数据包的生存时间 ，它是数据包可经过的最多路由器总数。TTL 初始值由源主机设置后，数据包在传输过程中每经过一个路由器，TTL 值则减 1 ，当该字段为 0 时，数据包被丢弃，并发送 ICMP 报文通知源主机，以防止源主机无休止地发送报文。这里扩展说一下 ICMP ( Internet Control Message Protocol，Internet控制报文协议 ），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。 ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重要，经常使用的 ping、tracert 命令就是基于 ICMP 检测网络状态的有力工具。

这里说明一下tracert命令，也被称为Windows路由跟踪实用程序，在cmd中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。

从左到右的5条信息分别代表了“生存时间”（每途经一个路由器结点自增1）、“三次发送的ICMP包返回时间”（共计3个，单位为毫秒ms）和“途经路由器的IP地址”（如果有主机名，还会包含主机名）。其中带有星号（*）的信息表示该次ICMP包返回时间超时。

如果在“tracert”命令后添加一个不存在的IP地址，tracert程序则会报错。

![1565493998028](E:\git_repo\Hao_Learn\2019\8\img\1565493998028.png)

IP 报文在互联网上传输时，可能要经历多个物理网络，才能从源主机到达目标主机。比如在手机上给某个 PC 端的朋友发送一个信息，经过无线网的 IEEE 802.1x 认证，转到光纤通信上，然后进入内部企业网 802.3 ，并最终到达目标 PC。由于不同硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度被称为最大传输单元，即 MTU ( Maximum Transmission Unit ）。那么在不同的物理网之间就可能需要对 IP 报文进行分片，这个工作通常由路由器负责完成。
IP是TCP／IP的基石，几平所有其他协议都建立在 IP 所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的 TCP。

#### 既然链路层可以通过唯一的 MAC 地址找到机器，为什么还需要通过唯一的 IP 地址再来标识呢？

简单地说，在世界范围内，不可能通过广播的方式，从数以千万计的计算机里找到目标 MAC 地址的计算机而不超时。在数据投递时就需要对地址进行分层管理。

#### TCP建立连接
TCP（Transmission Control Protocol,  传输控制协议），是一种面向连接、确保数据在端到端间可靠传输的协议。面向连接是插在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形。每个 TCP 数据包是封装在 IP 包中的，每个 IP头的后面紧接着的是 TCP 头。
![1565535187390](E:\git_repo\Hao_Learn\2019\8\img\1565535187390.png)

协议第一行的两个端口号各占两个字节，分别表示了源机器和目标机器的端口号。这两个端口号与 IP 报头中的源 IP 地址和目标 IP 地址所组成的四元组可唯一标识一条TCP 连接。由于 TCP 是面向连接的 ，因此有服务端和客户端之分。需要服务端先在相应的端口上进行监昕，准备好接收客户端发起的建立连接请求。当客户端发起第一个请求建立连接的 TCP 包时，目标机器端口就是服务端所监听的端口号。比如一些由国际组织定义的广为人知端口号一一代表 HTTP 服务的 80 端口、代表 SSH 服务的22 端口、代表 HTTPS 服务的 443 端口。可通过 netstat 命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。

![1565535499323](E:\git_repo\Hao_Learn\2019\8\img\1565535499323.png)

协议第二行和第二行是序列号，各占 4 个字节。前者是指所发送数据包中数据部
分第一个字节的序号，后者是指期望收到来自对方的下一个数据包中数据部分第一个字节的序号。

p35

------------------------

RPC 服务集群的注册中心与服务提供方、消费方之间，消息服务集群的缓存服务器和消费者服务器之间，应用后台服务器和数据库之间，都会使用**连接池**来提升性能。
数据库连接池负责分配、管理和释放连接，这是一种以内存空间换取时间的策略，能够明显地提升数据库操作的性能。但如果数据库连接管理不善，也会影响到整个应用集群的吞吐量。连接池配置错误加上**慢SQL** ，就像屋漏偏逢连夜雨，可以瞬间让一个系统进入服务超时假死宕机状态。

> 导致慢 SQL 的原因：
> 1. SQL编写问题
   >- 与索引相关的规则：
     - 字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；
     - mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；
     - 不要在字段前面加减运算；
     - 字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；
     - like % 在前面用不到索引；
     - 根据联合索引的第二个及以后的字段单独查询用不到索引；
     - 不要使用 select * ；
     - 排序请尽量使用升序 ;
     - or 的查询尽量用 union 代替 （InnoDB）；
     - 复合索引高选择性的字段排在前面；
     - order by / group by 字段包括在索引当中减少排序，效率会更高。
   >- 尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；
   - 分页语句 limit 的问题；
   - 删除表所有记录请用 truncate，不要用 delete；
   - 不让 mysql 干多余的事情，如计算；
   - 输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；
   - 在 Innodb上用 select count( * )，因为 InnoDB 会存储统计信息；
   - 慎用 Order by rand()。
>2. 锁
>3. 业务实例相互干绕对 IO/CPU 资源争用
>4. 服务器硬件
>5. MYSQL BUG
>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的分析诊断工具有：mysql dumpslow ;  mysql profile ;  mysql explain

连接数的创建是受到服务器操作系统的`fd`（文件描述符）数量限制的。创建更多的活跃连接，就需要消耗更多的`fd`，系统默认单个进程可同时拥有 1024 个`fd`，该值虽然可以适当调整，但如果无限制地增加，会导致服务器在`fd`的维护和切换上消耗过多的精力，从而降低应用吞吐量。

在双十一的场景里，应用服务器的全链路上不论是连接池的峰值处理，还是应用之间的调用频率，都会有相关的限流措施和降级预案。

一般可以把连接池的最大连接数设置在 30 个左右 理论上还可以设置更大的值，但是 DBA（Database Adiministrator） 一般不会允许，因为往往只有出现了慢 SQL 才需要使用更多的连接数。这时候通常需要优化应用层逻辑或者创建数据库索引，而不是一昧地采用加大连接数这种治标不治本的做法。极端情况下甚至会导致数据库服务不晌应，进而影响其他业务。

从经验上来看，在数据库层面的请求应答时间必须在100ms 以内，秒级的 SQL查询通常存在巨大的性能提升空间，有如下应对方案：

 1. 建立高效且合适的索引。

 2. 排查连接资源未显式关闭的情形。要特别注意在 ThreadLocal 或流式计算中使用数据库连接的地方。

 3. 合并短的请求。根据 CPU 的空间局部性原理，对于相近的数据， CPU会一起提取到内存中。另外，合并请求也可以有效减少连接的次数。

 4. 合理拆分多个表 join 的 SQL ，若是超过三个表则禁止 join 。如果表结构建得不合理，应用逻辑处理不当，业务模型抽象有问题，那么三表 join 的数据量由于笛卡儿积操作会呈几何级数增加，所以不推荐这样的做法。另外，对于需要join 的字段，数据类型应保持绝对一致。多表关联查询时，应确保被关联的字段要有索引。

 5. 使用临时表。在不断的嵌套查询中，已经无法很好地利用现有的索引提升查询效率，所以把中间结果保存到临时表，然后重建索引，再通过临时表进行后续的数据操作。

 6. 应用层优化。

 7. 改用其他数据库。[NoSQL数据库探讨](https://blog.csdn.net/hguisu/article/details/5748732)

#### 信息安全

现代黑客攻击的特点是分布式、高流量、深度匿名。黑客的攻击手段十分多样，大体可分为非破坏性攻击和破坏性攻击。非破坏性攻击－般是为了扰乱系统的运行，使之暂时失去正常对外提供服务的能力，比如 DDoS 攻击等。破坏性攻击主要会造成两种后果：系统数据受损或者信息被窃取，比如 CSRF 攻击等。黑客使用的攻击手段有病毒式、洪水式、系统漏洞式等。
现今云端提供商的优势在于能提供套完整的安全解决方案。离开云端提供商 ，一个小企业要从头到尾地搭建一套安全防御体系，技术成本和资源成本将是难以承受的。所以互联网企业都要建立一套完整的信息安全体系，遵循 CIA 原则 即保密性（ Confidentiality ) ，完整性（ Integrity )，可用性（ Availability ）。
- 保密性。 对需要保护的数据（比如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。在实际编程中，通常使用加密等手段保证数据的安全。
- 完整性。访问的数据需要是完整的，而不是缺失的或者被篡改的 不然用户访问的数据就是不正确的。在实际编写代码中，一定要保证数据的完整性，通常的做法是对数据进行签名和校验（比如 MD5和数字签名等）。
- 可用性。 服务需要是可用的。如果连服务都不可用，也就没有安全这一说了。对于这种情况通常使用访问控制、限流等手段解决。
以上三点是安全中最基本的三个要素，后面谈到的 Web 安全问题，都是围绕这三点来展开的。

p46