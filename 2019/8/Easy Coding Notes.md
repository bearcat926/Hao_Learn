# 第一章 计算机基础

## 1.1 走进0与1的世界

#### 为何负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32 位）和长整型（64 位）数上，假如在整型数上移动的位数是32 位，**无论是否带符号位以及移动方向，均为本身**。因为移动的位数是个mod 32 的结果，即 `35 >> 1` 与 `35 >> 33` 是一样的结果。如果是长整型， mod 64，即 `35 << 1` 与`35 << 65`的结果是一样的。负数在无符号往右移动 63 位时，除最右边为1， 左边均为0，达到最小值1，如果 >>> 64，则为其原数值本身。

```java
public class Test{

	public static void main(String[] args) {
		int a = 35;
		int b = -35;

		System.out.println("==========正数============");
		System.out.println(a >>> 1);

		System.out.println(a >>> 27);
		System.out.println(a >>> 28);
		System.out.println(a >>> 29);
		System.out.println(a >>> 30);
		System.out.println(a >>> 31);
		System.out.println(a >>> 32);
		System.out.println(a >>> 33);
		System.out.println("==========负数============");
		System.out.println(b >>> 1);

		System.out.println(b >>> 27);
		System.out.println(b >>> 28);
		System.out.println(b >>> 29);
		System.out.println(b >>> 30);
		System.out.println(b >>> 31);
		System.out.println(b >>> 32);
		System.out.println(b >>> 33);
	}
	
}
```

结果：

```
==========正数============
17	//1
0	//27
0
0
0
0	//31
35	//32
17
==========负数============
2147483630	//1
31	//27
15
7
3
1	//31
-35	//32
2147483630
```

#### 异或运算 ^

异或运算没有短路功能，一般在哈希算法中用于离散哈希值，对应的位上不一样才是1。



## 1.2 浮点数

#### 浮点数表示

当前业界流行的浮点数标准是 `IEEE754` ，该标准规定了4种浮点数类型：单精度、双精度、延伸单精度、延伸双精度。前两种类型是最常用的。

**浮点数无法表示零值。**

范围：

| 精度       | 字节数 | 正数取值范围             | 负数取值范围             |
| ---------- | ------ | ------------------------ | ------------------------ |
| 单精度类型 | 4      | `1.4e-45 至 3.4e+38`     | `-3.4e+38 至 -1.4e-45`   |
| 双精度类型 | 8      | `4.9e-324 至 1.798e+308` | `1.798e+308 至 4.9e-324` |

#### 阶码位

IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。

移码是将一个真值在数轴上正向平移一个偏移量之后得到的，即 [x]~移~ = x + 2^n-1^ （n为x的二进制位数，含符号位）。移码的几何意义是把真值映射到一个正数域，其特点是可以直观地反映两个真值的大小，即移码大的真值也大。

> 真值 = 阶码 - （2^n-1^ - 1）

#### 为什么偏移值为2^n-1^ - 1 而不是 2^n-1 呢？

因为8个二进制位能表示指数的取值范围为 [-128,127] ，现在将指数变成移码表示，即将区间 [-128,127] 正向平移到正数域，区间里的每个数都需要加上 128 ，从而得到阶码范围为[0,255 ] 。

由于计算机规定阶码全为 0 或全为 1 两种情况被当作特殊值处理（全 0 被认为是机器零，全 1 被认为是无穷大），去除这两个特殊值，阶码的取值范围变成了 [1,254] 。

如果偏移量不变仍为128 的话，则根据换算关系公式 [x]~阶~ = x + 128 得到指数的范围变成[-127,126]，指数最大只能取到 126 ，显然会缩小浮点数能表示的取值范围。

所以 IEEE754 标准规定单精度的阶码偏移量为 2^n-1^ - 1 （即 127 ），这样能表示的指数范围为[-126,127]，指数最大值能取到 127。

0**111-1111-0**111-1111-1111-1111-1111-1111

为了节约存储空间，将符合规格化位数的首个1省略，所以尾数表面上是23位，却表示了24位二进制数。

#### 加减运算
对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。

1. 零值检测。 检查参加运算的两个数中是否存在为 0 的数（ 0  在浮点数是一
种规定，即阶码与尾数全为 0 ），因为浮点数运算过程比较复杂，如果其中一个数为 0,可以直接得出结果。
2. 对阶操作。 通过比较阶码的大小判断小数点位置是否对齐。IEEE754 规定对阶的移动方向为向右移动，即选择阶码小的数进行操作。
3. 尾数求和。
4. 结果规格化。如果运算的结果仍然满足规格化形式，则无须处理，否则需要通过尾数位的向左或右移动调整达到规格化形式。尾数位向右移动称为右规，反之称为左规。
5. 结果舍入。在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃， 从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。

#### 浮点数使用
在使用浮点数时推荐使用**双精度**，使用单精度由于表示区间的限制 ，计算结果会出现微小的误差。
1. 在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储。
2. 在要求精确表示小数点 n 位的业务场景下，比如圆周率要求存储小数点后 1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推荐采用数组保存小数部分的数据。
3. 在比较浮点数时，由于存在误差，往往会出现意料之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。
4. 在数据库中保存小数时，推荐使用 `decimal` 类型，禁止使用 float 类型和 double 类型。因为这两种类型在存储的时候，存在精度损失的问题。

## 1.3 字符集与乱码
实现 Unicode 的编码格式有三种 UTF-8 UTF-16 UTF-32，UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为对Unicode 的压缩方式。根据二八原则，常用文字只占文字总数的 20% 左右。

在日常开发中，字符集如果不兼容则会造成乱码。

乱码的出现场景并不止于编码环境中，还有网页展示、文本转换、文件读取等。数据流从底层数据库到应用层，到Web 服务器，再到客户端显示，每位开发工程师都会碰到字符乱码的问题，排查起来是一个比较长的链路。

数据库是存储字符之源，在不同层次上都能够设置独立的字符集，如服务器级别、 schema 级别、表级别甚至列级别。为了减少麻烦，所有情况下的字符集设置最好是一致的。

## 1.4 CPU与内存
越往 CPU 核心靠近，存储越贵，速度越快。越往下，存储越便宜、速度越慢，当然容量也会更大。
程序员们最害怕的 OOM（Out Of Memory）通常来源于由于不恰当的编码方式而导致内存的资源耗尽 ，虽然现代内存的容量已经今非昔比，但仍然是可以在秒级内耗尽所有内存资源的。
内存的抽象就是线性空间内的字节数组，通过下标访问某个特定位置的数据，比如 C 语言使用 malloc（） 进行内存的分配，然后使用指针进行内存的读与写；而以 Java 为代表的编程语言，内存就交给 JVM 进行自动分配与释放，这个过程
称为垃圾回收机制。虽然垃圾回收机制能为程序员减负，但如果不加节制的话，同样会耗尽内存资源。

## 1.5 TCP / IP

#### 概述
TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协议／因特网互联协议，这个大家族里的其他知名协议还有 HTTP, HTTPS、 FTP、SMTP、UDP、 ARP、PPP、IEEE 802.x 等。它是当前流行的网络传输协议框架，从严格意义上讲它是一个协议族，因为 TCP、IP 是其中最为核心的协议，所以就把该协议族称为 TCP/IP 。
而另一个是耳熟能详的 ISO/OSI 的七层传输协议，其中 OSI( Open System Interconnection ）的出发点是想设计出计算机世界通用的网络通信基本框架，它已经被淘汰。
![1565492275741](E:\git_repo\Hao_Learn\2019\8\img\1565492275741.png)


- 链路层：单个0、1 是没有意义的，链路层以字节为单位把 0 与 1 进行分组，  定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。
![1565492513881](E:\git_repo\Hao_Learn\2019\8\img\1565492513881.png)
MAC 地址长 6个字节共 48 位，通常使用十六进制数表示。使用 ifconfig -a 命令即可看到 MAC 地址。MAC地址的前 24 位（3个字节）由管理机构统一分配，后24 位由厂商自己分配，保证网卡全球唯一。

- 网络层： 根据 IP 定义网络地址，区分网段。子网内根据ARP（Address Resolution Protocol，地址解析协议）进行 MAC 寻址，子网外进行路由转发数据包，这个数据包即 IP 数据包。
- 传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是 UDP和TCP。UDP 只是在 IP 数据包上增加端口等部分信息，是面向无连接的，是不可靠传输，多用于视频通信、电话会议等（即使少一帧数据也无妨）。与之相反的TCP 是面向连接的。所谓面向连接，是一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一条固定的通路承载着数据的可靠传输。
- 应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数
据。比如，E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是都能够读取邮件内容，是因为 SMTP （Simple Mail Transfer Protocol，简单邮件传输协议）就像传统的书信恪式一样，按规定填写邮编及收信人信息。

总结一下，程序在发送消息时，应用层按既定的协议打包数据，随后由传输层加
上双方的端口号 ，由网络层加上双方的 IP 地址，由链路层加上双方的 MAC 地址，并将数据拆分成数据帧，经过多个路由器和网关后，到达目标机器。简而言之，就是按**端口 -> IP 地址 -> MAC 地址 **这样的路径进行数据的封装和发送，解包的时候反过来操作即可

#### IP 协议

IP 是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP
首先规定出 IP 地址格式，该地址相当于在逻辑意义上进行了网段的划分，给每台计算机额外设置了一个唯一的详细地址。
IP 地址属于网络层，主要功能在 WLAN 内进行路由寻址，选择最佳路由。
![1565493293196](E:\git_repo\Hao_Learn\2019\8\img\1565493293196.png)
生存时间TTL（Time To Live），即数据包的生存时间 ，它是数据包可经过的最多路由器总数。TTL 初始值由源主机设置后，数据包在传输过程中每经过一个路由器，TTL 值则减 1 ，当该字段为 0 时，数据包被丢弃，并发送 ICMP 报文通知源主机，以防止源主机无休止地发送报文。这里扩展说一下 ICMP ( Internet Control Message Protocol，Internet控制报文协议 ），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。 ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重要，经常使用的 ping、tracert 命令就是基于 ICMP 检测网络状态的有力工具。

这里说明一下tracert命令，也被称为Windows路由跟踪实用程序，在cmd中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。

从左到右的5条信息分别代表了“生存时间”（每途经一个路由器结点自增1）、“三次发送的ICMP包返回时间”（共计3个，单位为毫秒ms）和“途经路由器的IP地址”（如果有主机名，还会包含主机名）。其中带有星号（*）的信息表示该次ICMP包返回时间超时。

如果在“tracert”命令后添加一个不存在的IP地址，tracert程序则会报错。

![1565493998028](E:\git_repo\Hao_Learn\2019\8\img\1565493998028.png)

IP 报文在互联网上传输时，可能要经历多个物理网络，才能从源主机到达目标主机。比如在手机上给某个 PC 端的朋友发送一个信息，经过无线网的 IEEE 802.1x 认证，转到光纤通信上，然后进入内部企业网 802.3 ，并最终到达目标 PC。由于不同硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度被称为最大传输单元，即 MTU ( Maximum Transmission Unit ）。那么在不同的物理网之间就可能需要对 IP 报文进行分片，这个工作通常由路由器负责完成。
IP是TCP／IP的基石，几平所有其他协议都建立在 IP 所提供的服务基础上进行传输，其中包括在实际应用中用于传输稳定有序数据的 TCP。

#### 既然链路层可以通过唯一的 MAC 地址找到机器，为什么还需要通过唯一的 IP 地址再来标识呢？

简单地说，在世界范围内，不可能通过广播的方式，从数以千万计的计算机里找到目标 MAC 地址的计算机而不超时。在数据投递时就需要对地址进行分层管理。

#### TCP建立连接
TCP（Transmission Control Protocol,  传输控制协议），是一种面向连接、确保数据在端到端间可靠传输的协议。面向连接是插在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形。每个 TCP 数据包是封装在 IP 包中的，每个 IP头的后面紧接着的是 TCP 头。
![1565535187390](E:\git_repo\Hao_Learn\2019\8\img\1565535187390.png)

协议第一行的两个端口号各占两个字节，分别表示了源机器和目标机器的端口号。这两个端口号与 IP 报头中的源 IP 地址和目标 IP 地址所组成的四元组可唯一标识一条TCP 连接。由于 TCP 是面向连接的 ，因此有服务端和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的建立连接请求。当客户端发起第一个请求建立连接的 TCP 包时，目标机器端口就是服务端所监听的端口号。比如一些由国际组织定义的广为人知端口号一一代表 HTTP 服务的 80 端口、代表 SSH 服务的22 端口、代表 HTTPS 服务的 443 端口。可通过 netstat 命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。

![1565535499323](E:\git_repo\Hao_Learn\2019\8\img\1565535499323.png)

协议第二行和第二行是序列号，各占 4 个字节。前者是指所发送数据包中数据部
分第一个字节的序号，后者是指期望收到来自对方的下一个数据包中数据部分第一个字节的序号。

由于 TCP 报头中存在一些扩展字段，所以需要通过长度为 4 个 bit 的头部长度字段表示 TCP 报头的大小，这样接收方才能准确地计算出包中数据部分的开始位置。

TCP 的 FLAG 位由 6 个 bit 组成，分别代表 ACK、SYN、FIN、 URG、PSH、RST ，都以置1 表示有效。SYN ( Synchronize Sequence Numbers ）用作建立连接时的同步信号；ACK ( Acknowledgement ）用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN ( Finish ）表示后面没有数据需要发送，通常意昧着所建立的连接需要关闭了。
URG（紧急位）：设置为1时，首部中的紧急指针有效。PSH（推位）：当设置为1时，要求把数据尽快的交给应用层，不做处理，通常的数据中都会带有PSH，但URG只在紧急数据的时设置，也称“带外数据“；RST表示复位，用来异常的关闭连接。在发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。
![1565717495945](E:\git_repo\Hao_Learn\2019\8\img\1565717495945.png)

三次握手有两个主要目的：信息对等和防止超时。先从信息对等角度来看，双方只有确定4 类信息（自己/对方的发报/收报能力），才能建立连接。再者是防止出现请求超时导致脏连接。 TTL 网络报文的生存时间往往都会超过 TCP 请求超时时间，如果两次握手就可以创建连接，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B机器会以为是A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据，以致最后只是 B 机器单方面创建连接完毕。

![1565717542453](E:\git_repo\Hao_Learn\2019\8\img\1565717542453.png)

从编程的角度， TCP 连接的建立是通过文件描述待（ File Descriptor ，fd） 完成的。通过创建套接字获得一个 fd，然后服务端和客户端需要基于所获得的 fd调用不同的函数分别进入监听状态和发起连接请求。由于 fd 的数量将决定服务端进程所能建立连接的数量 ，对于大规模分布式服务来说，当 fd 不足时就会出现 `open too many files` 错误而使得无法建立更多的连接。为此，需要注意调整服务端进程和操作系统所支持的最大文件句柄数。通过使用 `ulimit -n` 命令来查看单个进程可以打开文件句柄的数量。如果想查看当前系统各个进程产生了多少句柄，可以使用如下的命令：
>lsof -n | awk '{print $2}' | sort|uniq -c |sort -nr|more

![1565718109948](E:\git_repo\Hao_Learn\2019\8\img\1565718109948.png)
左侧列是句柄数，右侧列是进程号。
`lsof` 命令用于查看当前系统所打开 fd 的数量。在 Linux 系统中，很多资源都是以 fd 的形式进行读写的，除了提到的文件和 TCP 连接 UDP 数据报、输入输出设备等都被抽象成了 fd。

TCP 在协议层面支持 Keep Alive 功能，即隔段时间通过向对方发送数据表示连接处于健康状态。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳包检查连接的健康度。一旦心跳包出现异常不仅会主动关闭连接，还会回收与连接相关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。

#### TCP断开连接
TCP 是全双工通信，双方都能作为数据的发送方和接收方，但 TCP 连接也会有断开的时候。

![1565718820471](E:\git_repo\Hao_Learn\2019\8\img\1565718820471.png)

图中的红色字体所示的 TIME_WAIT 和 CLOSE_WAIT 分别表示主动关闭和被动关闭产生的阶段性状态，如果在线上服务器大量出现这两种状态，就会加重机器负载，也会影响有效连接的创建，因此需要进行有针对性的调优处理。
• TIME_WAIT：主动要求关闭的机器表示收到了对方的 FIN 报文，并发送出了ACK 报文，进入 TIME_WAIT 状态，等 2MSL 后即可进入到 CLOSED 状态。如果 FIN_WAIT_1 状态下，同时收到带 FIN 标志和 ACK 标志的报文时，可以直接进入 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。
• CLOSE_WAIT： 被动要求关闭的机器收到对方请求关闭连接的 FIN 报文，在第一次 ACK 应答后，马上进入 CLOSE_WAIT 状态。这种状态其实表示在等待关闭，并且通知应用程序发送剩余数据，处理现场信息，关闭相关资源。

在TME_WAIT 等待的 2MSL 是报文在网络上生存的最长时间，超过阈值便将报文丢弃。一般来说， MSL 大于 TTL 衰减至 0 的时间。在RFC793 中规定 MSL 为2 分钟。但是在当前的高速网络中， 2分钟的等待时间会造成资源的极大浪费，在高并发服务器上通常会使用更小的值。既然 TIME_WAIT 貌似是百害而无一利的，为何不直接关闭，进入 CLOSED 状态呢？原因有如下几点。
1. 确认被动关闭方能够顺利进入 CLOSED 状态。假如最后一个 ACK 由于网络原因导致无法到达 B 机器，处于 LAST_ACK 机器通常 “自信” 地以为对方没有收到自己的 FIN+ACK 报文，所以会重发。 A 机器收到第二次的 FIN+ACK 报文，会重发一次 ACK ，并且重新计时。
2. 防止失效请求。这样做是为了防止己失效连接的请求数据包与正常连接的
请求数据包混淆而发生异常。因为 TIME_WAIT 状态无法真正释放句柄资源，在此期间，Socket 中使用的本地端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高并发服务器来说，会极大地限制有效连接的创建数量，成为性能瓶颈。所以，建议将高并发服务器 TIME_WAIT 超时时间调小。
在服务器上通过变更`/etc/sysctl.conf` 文件来修改该省略值（秒）：`net.ipv4.tcp_fin_timeout = 30` （建议小于 30 秒为宜）。
修改完之后执行`/sbin/sysctl -p` 让参数生效即可。可以通过如下命令：
>netstat -n |awk '/^tcp/	{++S[$NF]}	END	{for(a in S)	print	a,	S[a] }'

查看各连接状态的计数情况，为了使数据快速生效， 2MSL 从 240 秒更改为5 秒。
在`sysctl.conf` 中还有其他连接参数也用来不断地调优服务器 TCP 连接能力，以提升服务器的有效利用率。如何快速地使连接资源被释放和复用，参数的优化往往可以取得事半功倍的效果。

TIME_WAIT 是挥手四次断开连接的尾声，如果此状态连接过多，则可以通过优化服务器参数得到解决。如果不是对方连接的异常，一般不会出现连接无法关闭的情况。但是 CLOSE_WAIT 过多很可能是程序自身的问题，比如在对方关闭连接后，程序没有检测到，或者忘记自己关闭连接。在某次故障中，外部请求出现超时的情况，当时的 Apache 服务器使用的是默认的配置方式，通过命令`netstat -ant|grep -i "443"|grep CLOSE_ WAIT|wc -l`发现在HTTPS 的 443 端口上堆积了 2.1 万个左右的CLOSE_WAIT 状态。经排查发现，原来是某程序处理完业务逻辑之后没有释放流操作，但程序一直运行正常，直到运营活动时才大量触发该业务逻辑，最终导致故障的产生。

#### 连接池
RPC 服务集群的注册中心与服务提供方、消费方之间，消息服务集群的缓存服务器和消费者服务器之间，应用后台服务器和数据库之间，都会使用**连接池**来提升性能。
数据库连接池负责分配、管理和释放连接，这是一种以内存空间换取时间的策略，能够明显地提升数据库操作的性能。但如果数据库连接管理不善，也会影响到整个应用集群的吞吐量。连接池配置错误加上**慢SQL** ，就像屋漏偏逢连夜雨，可以瞬间让一个系统进入服务超时假死宕机状态。

> 导致慢 SQL 的原因：
> 1. SQL编写问题
   >- 与索引相关的规则：
     - 字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；
     - mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；
     - 不要在字段前面加减运算；
     - 字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；
     - like % 在前面用不到索引；
     - 根据联合索引的第二个及以后的字段单独查询用不到索引；
     - 不要使用 select * ；
     - 排序请尽量使用升序 ;
     - or 的查询尽量用 union 代替 （InnoDB）；
     - 复合索引高选择性的字段排在前面；
     - order by / group by 字段包括在索引当中减少排序，效率会更高。
   >- 尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；
   - 分页语句 limit 的问题；
   - 删除表所有记录请用 truncate，不要用 delete；
   - 不让 mysql 干多余的事情，如计算；
   - 输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；
   - 在 Innodb上用 select count( * )，因为 InnoDB 会存储统计信息；
   - 慎用 Order by rand()。
>2. 锁
>3. 业务实例相互干绕对 IO/CPU 资源争用
>4. 服务器硬件
>5. MYSQL BUG
>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的分析诊断工具有：mysql dumpslow ;  mysql profile ;  mysql explain

连接数的创建是受到服务器操作系统的`fd`（文件描述符）数量限制的。创建更多的活跃连接，就需要消耗更多的`fd`，系统默认单个进程可同时拥有 1024 个`fd`，该值虽然可以适当调整，但如果无限制地增加，会导致服务器在`fd`的维护和切换上消耗过多的精力，从而降低应用吞吐量。

在双十一的场景里，应用服务器的全链路上不论是连接池的峰值处理，还是应用之间的调用频率，都会有相关的限流措施和降级预案。

一般可以把连接池的最大连接数设置在 30 个左右 理论上还可以设置更大的值，但是 DBA（Database Adiministrator） 一般不会允许，因为往往只有出现了慢 SQL 才需要使用更多的连接数。这时候通常需要优化应用层逻辑或者创建数据库索引，而不是一昧地采用加大连接数这种治标不治本的做法。极端情况下甚至会导致数据库服务不晌应，进而影响其他业务。

从经验上来看，在数据库层面的请求应答时间必须在100ms 以内，秒级的 SQL查询通常存在巨大的性能提升空间，有如下应对方案：

 1. 建立高效且合适的索引。

 2. 排查连接资源未显式关闭的情形。要特别注意在 ThreadLocal 或流式计算中使用数据库连接的地方。

 3. 合并短的请求。根据 CPU 的空间局部性原理，对于相近的数据， CPU会一起提取到内存中。另外，合并请求也可以有效减少连接的次数。

 4. 合理拆分多个表 join 的 SQL ，若是超过三个表则禁止 join 。如果表结构建得不合理，应用逻辑处理不当，业务模型抽象有问题，那么三表 join 的数据量由于笛卡儿积操作会呈几何级数增加，所以不推荐这样的做法。另外，对于需要join 的字段，数据类型应保持绝对一致。多表关联查询时，应确保被关联的字段要有索引。

 5. 使用临时表。在不断的嵌套查询中，已经无法很好地利用现有的索引提升查询效率，所以把中间结果保存到临时表，然后重建索引，再通过临时表进行后续的数据操作。

 6. 应用层优化。

 7. 改用其他数据库。因为不同数据库针对的业务场景是不同的。

    [NoSQL数据库探讨](https://blog.csdn.net/hguisu/article/details/5748732)

## 1.6信息安全

#### 黑害与安全
现代黑客攻击的特点是分布式、高流量、深度匿名。黑客的攻击手段十分多样，大体可分为非破坏性攻击和破坏性攻击。**非破坏性攻击**一般是为了扰乱系统的运行，使之暂时失去正常对外提供服务的能力，比如 DDoS 攻击等。**破坏性攻击**主要会造成两种后果：系统数据受损或者信息被窃取，比如 CSRF 攻击等。黑客使用的攻击手段有病毒式、洪水式、系统漏洞式等。
现今云端提供商的优势在于能提供套完整的安全解决方案。离开云端提供商 ，一个小企业要从头到尾地搭建一套安全防御体系，技术成本和资源成本将是难以承受的。所以互联网企业都要建立一套完整的信息安全体系，遵循 CIA 原则 即保密性（ Confidentiality ) ，完整性（ Integrity )，可用性（ Availability ）：

- 保密性。 对需要保护的数据（比如用户的私人信息等）进行保密操作，无论是存储还是传输，都要保证用户数据及相关资源的安全。在实际编程中，通常使用加密等手段保证数据的安全。
- 完整性。访问的数据需要是完整的，而不是缺失的或者被篡改的 不然用户访问的数据就是不正确的。在实际编写代码中，一定要保证数据的完整性，通常的做法是对数据进行签名和校验（比如 MD5和数字签名等）。
- 可用性。 服务需要是可用的。如果连服务都不可用，也就没有安全这一说了。对于这种情况通常使用访问控制、限流等手段解决。
以上三点是安全中最基本的三个要素，后面谈到的 Web 安全问题，都是围绕这三点来展开的。

#### SQL 注入

SQL 注入是注入式攻击中的常见类型，即由于未将代码与数据进行严格的隔离 ，导致在读取用户数据的时候，错误地把数据作为代码的一部分执行而导致一些安全问题。
预防手段：
1. 过滤用户输入参数中的特殊字符 ，从而降低被 SQL注入的风险。
2. 禁止通过字符串拼接的 SQL 语句 ，严恪使用参数绑定传入的 SQL 参数。
3. 合理使用数据库访问框架提供的防注入机制。

#### XSS 与 CSRF

跨站脚本攻击，即`Cross-Site Scripting` ，为了不和前端开发中层叠样式表 `CSS` 的名字冲突，简称为XSS。 XSS 是指黑客通过技术手段，向正常用户请求的 HTML 页面中插入恶意脚本，从而可以执行任意脚本。 XSS主要分为反射型 XSS 、存储型 XSS和DOM型XSS。XSS 主要用于信息窃取、破坏等目的。
跨站请求伪造（ Cross-Site Request Forgery ），简称 CSRF， 也被称为 One-click Attack，即在用户并不知情的情况下，冒充用户发起请求，在当前已经登录的 Web 应用程序上执行恶意操作，如恶意发帖、修改密码、发邮件等。
在防范 XSS 上，主要通过对用户输入数据做过滤或者转义。比如 Java 开发人员可以使用 Jsoup 框架对用户输入字符串做 XSS 过滤，或者使用框架提供的工具类对用户输入的字符串做 HTML 转义，例如 Spring 框架提供的 HtmlUtils 。前端在浏览器展示数据时，也需要使用安全的 API 展示数据，比如使用 innerText 而不是innerHTML 。

CSRF 有别于 XSS ，从攻击效果上，两者有重合的地方。从技术原理上两者有本质的不同，XSS 是在正常用户请求的 HTML 页面中执行了黑客提供的恶意代码；CSRF是黑客直接盗用用户浏览器中的登录信息，冒充用户去执行黑客指定的操作。
防范 CSRF 漏洞主要通过以下方式：
1. CSRF Token 验证，利用浏览器的同源限制，在 HTTP 接口执行前验证页面或者 Cookie 中设置的 Token ，只有验证通过才继续执行请求。
2. 人机交互 ，比如在调用上述网上银行转账接口时校验短信验证码。

XSS 问题出在用户数据没有过滤、转义；CSRF 问题出在 HTTP 接口没有防范不受信任的调用。

#### HTTPS
安全套接字层( Secure Socket Layer, SSL ）。SSL 协议工作于传输层与应用层之间，为应用提供数据的加密传输。而 HTTPS 的全称是 HTTP over SSL ，简单的理解就是在之前的 HTTP 传输上增加了 SSL 协议的加密能力。

我们可以通过对称加密算法对数据进行加密，比如 DES ，即 一个主站与用户之间可以使用相同的密钥对传输内容进行加解密。但密钥几乎没有什么保密性可言，被盗之后就会被破解。

RSA 把密码革命性地分成公钥和私钥，由于两个密钥并不相同，所以称为非对称加密。私钥是用来对公钥加密的信息、进行解密的，是需要严格保密的。公钥是对信息进行加密，任何人都可以知道，包括黑客。
非对称加密的安全性是基于大质数分解的困难性，在非对称的加密中公钥和私钥是一对大质数函数。计算两个大质数的乘积是简单的，但是这个过程的逆运算（即将这个乘积分解为两个质数）是非常困难的。而在 RSA 的算法中，从一个公钥和密文中解密出明文的难度等同于分解两个大质数的难度。因此在实际传输中，可以把公钥发给对方。一方发送信息时，使用另一方的公钥进行加密生成密文。收到密文的一方再用私钥进行解密，这样一来，传输就相对安全了。
但是非对称加密并不是完美的，它有一个很明显的缺点是加密和解密耗时长，只适合对少量数据进行处理。而且在解决了加密危机之后又产生了信任危机。

CA ( Certificate Authority）就是颁发 HTTPS 证书的组织。 HTTPS 是当前网站的主流文本传输协议，在基于 HTTPS 进行连接时，就需要数字证书。

```
访问一个 HTTPS 的网站的大致流程如下：
1. 浏览器向服务器发送请求，请求中包括浏览器支持的协议，并附带一个随机数。
2. 服务器收到请求后，选择某种非对称加密算法，把数字证书签名公钥、身份信息发送给浏览器，同时也附带一个随机数。
3. 浏览器收到后，验证证书的真实性，用服务器的公钥发送握手信息给服务器。
4. 服务器解密后，使用之前的随机数计算出一个对称加密的密钥，以此作为加密信息并发送。
5. 后续所有的信息发送都是以对称加密方式进行的。
```

传输层安全协议（ Transport Layer Security，TLS）的概念。这里先解释 TLS和SSL 的区别。 TLS 可以理解成 SSL 协议 3.0 版本的升级，所以 TLS 1.0 版本也被标识为 SSL 3.1 版本。但对于大的协议栈而言，SSL 和 TLS 并没有太大的区别，因此在 Wireshark 里，分层依然用的是安全套接字层（SSL）标识。

在整个 HTTPS 的传输过程中，主要分为两部分：首先是 HTTPS 的握手，然后是数据的传输。前者是建立一个 HTTPS 的通道，并确定连接使用的加密套件及数据传输使用的密钥。而后者主要使用密钥对数据加密并传输。

首先来看 HTTPS 是如何进行握手的，如图 1-28 所示是一个完整的 SSL 数据流和简单流程。

![1565768288645](E:\git_repo\Hao_Learn\2019\8\img\1565768288645.png)

第一，客户端发送了 Client Hello 协议的请求：在 Client Hello 中最重要的信息是 Cipher Suites 字段，这里客户端会告诉服务端自己支持哪些加密的套件。比如在这次 SSL 连接中，客户端支持的加密套件协议如图 1-29 所示。

![1565768515498](E:\git_repo\Hao_Learn\2019\8\img\1565768515498.png)

第二，服务端在收到客户端发来的 Client Hello 的请求后，会返回一系列的协议数据，并以一个没有数据内容的 Server Hello Done 结束。这些协议数据有的是单独发送，有的则是合并发送， 这里分别解释下几个比较重要的协议，如图 1-30 所示。

![1565768642195](E:\git_repo\Hao_Learn\2019\8\img\1565768642195.png)

1. Server Hell 协议。主要告知客户端后续协议中要使用的 TLS 协议版本，这个版本主要和客户端与服务端支持的最高版本有关。比如本次确认后续的 TLS 协议版本是 TLS v1.2 ，并为本次连接分配 个会话 ID ( Session ID ）。此外，还会确认后续采用的加密套件（ Cipher Suite ）， 这里确认使用的加密套件为 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 。该加密套件的基本含义为：使用非对称协议加密 （RSA） 进行对称协议加密 （AES） 密钥的加密，并使用对称加密协议 （AES） 进行信息的加密。
2. Certificate 协议。主要传输服务端的证书内容。
3. Server Key Exchange。如果在 Certificate 协议中未给出客户端足够的信息，则会在 Server Key Exchange 进行补充。比如在本次连接中 Certificate 未给出证书的公钥 （Public Key）， 这个公钥的信息将会通过 Server Key Exchange 发送给客户端。

4. Certificate Request。这个协议是一个可选项，当服务端需要对客户端进行证书验证的时候，才会向客户端发送一个证书请求（Certificate Request）。
5. 最后以 Server Hello Done 作为结束信息，告知客户端整个 Server Hello 过程结束。

第三，客户端在收到服务端的握手信息后，根据服务端的请求，也会发送一系列的协议。

1. Certificate。它是可选项。因为上文中服务端发送了 Certificate Request 需要对客户端进行证书验证，所以客户端要发送自己的证书信息。
2. Client Key Exchange。它与上文中 Server Key Exchange 类似， 是对客户端 Certificate 信息的补充。
3. Certification Verity。 对服务端发送的证书信息进行确认。
4. Change Cipher Spec。该协议不同于其他握手协议（Handshake Protocol ），而是作为一个独立协议告知服务端，客户端已经接收之前服务端确认的加密套件，并会在后续通信中使用该加密套件进行加密。
5.  Encrypted Handshake Message。用于客户端给服务端加密套件加密一段 Finish 的数据，用以验证这条建立起来的加解密通道的正确性。

第四，服务端在接收客户端的确认信息及验证信息后，会对客户端发送的数据进行确认，这里也分为几个协议进行回复。

1. Change Cipher Spec。通过使用私钥对客户端发送的数据进行解密，并告知后续将使用协商好的加密套件进行加密传输数据。
2. Encrypted Handshake Message。与客户端的操作相同，发送一段 Finish 的加密数据验证加密通道的正确性。

最后，如果客户端和服务端都确认加解密无误后，各自按照之前约定的 Session Secret 和 Application Data 进行加密传输。


# 第二章 面向对象

## 2.1 OOP 理念

面向过程的结构相对松散，强调如何流程化地解决问题；面向对象的思维更加内聚，强调高内聚、低藕合，先抽象模型，定义共性行为，再解决实际问题。

面向对象思维，以对象模型为核心，丰富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象能力显得尤为重要；封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，更具有维护性；继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有复用性；多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间。抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础。

#### 抽象

在面向对象的思维中，抽象分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行归一化的逻辑思维过程；后者则是从本质到具体，从共性到个性，逐步形象化的过程。在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已有问题解决方案的基础上，正确地找到合适的使用场景。

Java 之父 Gosling 设计的 Object 类，是任何类的默认父类，是对万事万物的抽象，是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。

|抽象问题|Object类的实现|
|------|--------|
|我是谁？|getClass() 说明本质上是谁，而 toString() 是当前职位的名片。|
|我从哪里来？|Object() 构造方法是生产对象的基本步骤，clone() 是繁殖对象的另一种方式。|
|我到哪里去？|finalize() 在对象销毁时触发的方法。|
|世界是否因你而不同？|hashCode() 和 equals() 就是判断与其他元素是否相同的一组方法。|
|与他人如何协调？|wait() 和 notify() 是对象间通信与协作的一组方法。|

clone()  方法分为浅拷贝、一般深拷贝和彻底深拷贝 。浅拷贝只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指向的实际对象；而彻底深拷贝是在成功 clone 一个对象之后，此对象与母对象在任何引用路径上都不存在共享的实例对象 ，即**深拷贝把所有引用变量所指向的变量都拷贝了一份**，但是引用路径递归越深，则越接近 JVM 底层对象，且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深拷贝。归根结底， 慎用 Object 的 clone() 方法来拷贝对象，因为对象的 clone() 方法默认是浅拷贝，若想实现深拷贝，则需要覆写 clone () 方法实现引用对象的深度遍历式拷贝。

随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如 finalize()方法在 JDK9 之后直接被标记为过时方法。而 wait() 和 notify() 同步方式事实上已经被同步信号、锁、阻塞集合等取代。

#### 封装

封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感方法或者外部不需要感知的复杂逻辑处理， 一般也会进行封装。封装使面向对象的世界变得单纯，对象之间的关系变得简单，各人自扫门前雪，耦合度变弱，有利于维护。

设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即 A模块使用
B 模块的某个接口行为，对 B 模块中除此行为之外的其他信息知道得尽可能少。

#### 继承

继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系，形成一个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用，父类的能力通过这种方式赋予子类。继承把代码变得更有层次感，更有扩展性，为多态打下语法基础。

人人都说继承是 is-a 关系，那么如何衡量当前的继承关系是否满足 is-a 关系呢？判断标准即是否符合里氏代换原则（ Liskov Substitution Principle, LSP ）。 LSP 是指任何父类能够出现的地方，子类都能够出现。在实际代码环境中，如果父类引用直接使用子类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个类之间符合 LSP 原则，可以使用继承关系。

继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样容易被滥用，我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆炸。

方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为的能力 ，比如鸟会飞，驼鸟继承鸟，发现飞不了，这就是方法污染。子类继承父类则说明子类对象可以调用父类对象的一切行为。在这样的情况下，总不能在继承时，添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方法，抛出异常，以阻止别人的调用。

方法爆炸是指继承树不断扩大，底层类拥有的方法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，很容易在实际编程中产生选择困难症。在实际故障中，因为方法爆炸，父类的某些方法签名和子类非常相似，在 IDE 中，输入`类名＋. `之后，在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述，提倡组合优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而不是继承。

#### 多态

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。

我们来明确两个非常容易混淆的概念 `override` 和 `overload`，`override`译成 `覆写`， 是子类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是**垂直方向**上行为的不同实现。`overload`译成`重载`，方法名称是相同的，但是参数类型或参数个数是不相同的，是**水平方向**上行为的不同实现。

多态是指在编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由 JVM 进行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。严格意义上来说，多态并不是面向对象的一种特质，而是一种由继承行为衍生而来的进化能力而已。

## 2.3 类

类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有 public 和无访问控制符，类型分 class、interface、enum。
Java 类主要由两部分组成：成员和方法。在定义 Java 类时，推荐首先定义变量，然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展示；保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法，因此重要性仅次于公有方法；而私有方法对外部来说是一个黑盒实现，因此一般不需要被特别关注；最后是 gette /setter 方法，虽然它们也是公有方法，但是因为承载的信息价值较低，一般不包含业务逻辑，所以所有 getter/setter 方法须放在类最后。

#### 接口与抽象类

定义类的过程就是抽象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行为和特征。

|语法维度|抽象类|接	口|
|------------|----------|------------|
|定义关键字|abstract|interface|
|子类继承或实现关键字|extends|implements|
|方法实现|可以有|不能有，但在JDK8及之后，允许有default实现|
|方法访问控制符|无限制|有限制，默认是public abstract类型|
|属性访问控制符|无限制|有限制，默认是public static final类型|
|静态方法|可以有|不能有|
|static{} 静态代码块|可以有|不能有|
|本类型之间扩展|单继承|多继承|
|本类型之间扩展关键字|extends|extends|

抽象类在被继承时体现的是 `is-a` 关系，接口在被实现时体现的是 `can-do` 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等 于一个接口。 `is-a`关系需要符合里氏代换原则；`can-do`关系要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为。

抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，性格偏内向，可以存在不同版本的实现；接口是开放的，性格偏外向，它就像一份合同，定义了方法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它，但想实现它的类必须遵守这份接口约定合同。

接口是顶级的“类”，虽然关键字是 interface ，但是编译之后的字节码扩展名还
`.class`。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后实现部分接口行为，其中 AbstractCollection 是最典型的抽象类：

```java
public abstract class AbstractCollection<E> implements Collection<E> {


}
```

Java 语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的绑定机制会变得非常复杂。接口继承接口，关键字是 extends ，而不是 implements，允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实体类在实现多重继承后的接口时，只是说明`can do many things `。当纠结定义接口还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接口，然后再用抽象类去 implements 某些接口，这样做可方便后续的扩展和重构。

#### 内部类

在一个 `.java` 源文件中，只能定义一个类名与文件名完全一致的公开类，使用`public class` 关键字来修饰。但在面向对象语言中，任何一个类都可以在内部定义另外一个类 ，前者为外部类，后者为内部类。

p68

https://blog.csdn.net/xuzhimin1991/article/details/82691256
http://www.throwable.club/
http://www.throwable.club/2019/05/05/design-pattern-basic-law/#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F
