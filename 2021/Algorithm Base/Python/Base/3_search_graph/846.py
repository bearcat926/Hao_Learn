"""
树的重心
给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

输入格式
第一行包含整数n，表示树的结点数。

接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。

输出格式
输出一个整数m，表示将重心删除后，剩余各个连通块中点数的最大值。

数据范围
1≤n≤10^5
输入样例
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
输出样例：
4

树是一种特殊的图（无环连通图）

图

    无向图（边无方向）:  a - b => a -> b, b -> a
    有向图（边有方向）: a -> b

    由此可以将 无向图 化简为 有向图

    存储方式

        邻接矩阵 g[a, b] => a, b
            有权重, 则g[a, b]存储权重
            无权重, 则g[a, b]存储布尔值（True 则有边, False 则无边）

            邻接矩阵不能存储重边, 一般只保存一条边

        邻接表 -> 多单链表, 类似于拉链法
"""
N = 10 ** 5 + 10
index, c, n = 0, N, 0
Bool = [False] * N
H, E, NE = [-1] * N, [-1] * (2 * N), [-1] * (2 * N)  # 无向图有两条边，所以开2N数组


def insert(a, b):
    global index
    # 头插法
    E[index] = b
    NE[index] = H[a]
    H[a] = index
    index += 1


def dfs(k):
    global c
    Bool[k] = True

    i = H[k]  # 当前节点的链表头索引
    sum_, r = 1, 0
    while i != -1:
        j = E[i]  # 联通节点
        if Bool[j] is not True:
            r_ = dfs(j)
            r = max(r_, r)  # 取子节点所在连通图的最大节点数
            sum_ += r_
        i = NE[i]

    r = max(r, n - sum_)  # 去掉当前节点后的最大连通图的节点数
    c = min(c, r)  # 遍历所有节点，得到的，去掉当前节点后最大连通图的节点数的最小值
    return sum_  # 当前节点（与其子树组成的）的连通块的节点数


if __name__ == '__main__':
    n = int(input())
    for i in range(n - 1):
        a, b = map(int, input().split())
        insert(a, b)
        insert(b, a)
    dfs(1)
    print(c)
