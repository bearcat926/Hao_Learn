"""
Dijkstra求最短路 I
给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

输入格式
第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

输出格式
输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

数据范围
1≤n≤500,
1≤m≤10^5,
图中涉及边长均不超过10000。

输入样例：
3 3
1 2 2
2 3 1
1 3 4
输出样例：
3
=====================================
最短路

    单源最短路

        定义
            1个点到其他所有点的最短距离(n为节点数, m为边数)

        分类
            所有边权都是正数

                朴素Dijkstra算法 O(n^2) => 适合稠密图(m >> n)

                堆优化Dijkstra算法 O(m*log_n) => 适合稀疏图(m 和 n 是一个级别 且 n,m <= 10^5)

            存在负权边

                Bellman-Ford算法 O(n*m)

                SPFA算法 avg: O(m), worst: O(n*m) -> Bellman-Ford算法的优化

    多源汇最短路

        定义
            1. 源点 -> 起点, 汇点 -> 终点
            2. 求给定两点中, 任选一点作为起点, 另一点作为终点, 计算从起点走到终点的最小路径

        Floyd算法 O(n^3) -> 基于正态规划
=====================================
    Dijkstra算法 -> 基于贪心
Bellman-Ford算法 -> 基于离散数学
       Floyd算法 -> 基于动态规划
=====================================
朴素Dijkstra算法
    1. 初始化距离: D[1] = 0, D[i] = N
    2. 循环并查找不在 S(存放当前已经确定最短距离的点)中的距离最短的点 t, 添加到 S中
    3. 用 t的边更新其他的点x: D[x] > D[t] + W
    4. 每次循环确定1个点的最小距离, 循环 n次

    稠密图 -> 邻接矩阵
    稀疏图 -> 邻接表
=====================================
自环: 节点存在连接自己的边
重边: 存在多条连接两结点的边

"""
N, M = 500 + 10, 10 ** 5 + 10
MAX = 2 ** 32
G = [[MAX] * N for i in range(N)]  # 点与点之间距离设为MAX，可以节省判断，也便于min计算
S, D = [False] * N, [MAX] * N


def insert(a, b, v):
    if a != b:  # 处理自环
        G[a][b] = min(G[a][b], v)  # 处理重边


def dijkstra():
    D[1] = 0  # 初始值
    for i in range(n):
        # 1. 取当前不在S中的最短路点
        t = 0
        for j in range(1, n + 1):
            if S[j] is not True and (t == 0 or D[t] > D[j]):
                t = j

        if t == n:  # 优化出口
            break

        # 2. 标记为最短路节点
        S[t] = True

        # 3. 根据t的边更新其它节点的最短路
        for j in range(1, n + 1):
            D[j] = min(G[t][j] + D[t], D[j])

    print(-1 if D[n] == MAX else D[n])


if __name__ == '__main__':
    n, m = map(int, input().split())
    for i in range(m):
        x, y, z = map(int, input().split())
        insert(x, y, z)
    dijkstra()
