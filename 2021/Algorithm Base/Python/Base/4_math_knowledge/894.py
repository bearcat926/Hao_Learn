"""
拆分-Nim游戏
给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子
（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 堆石子的数量 ai。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1 ≤ n, ai ≤ 100
输入样例：
2
2 3
输出样例：
Yes
================================================================
相比于集合-Nim，这里的每一堆可以变成不大于原来那堆的任意大小的两堆
即 a[i]可以拆分成 (b[i], b[j])
为了避免重复规定 b[i] >= b[j]，即：a[i] >= b[i] >= b[j],
相当于一个局面拆分成了两个局面，由 SG函数理论，多个独立局面的 SG值，等于这些局面 SG值的异或和。
因此需要存储的状态就是 sg(b[i]) ^ sg(b[j])（与集合-Nim的唯一区别）
"""
N, M = 100 + 10, 10000 + 10
# F存储的是所有可能出现过的情况的 SG值, 初始化 F均为 -1,方便查看 SG(x)是否被记录过
F = [-1] * M


def SG(x):
    # 因为取石子数目的集合 S是已经确定了的,
    # 所以在递归条件下，每个数的 SG值也都是确定的, 如果F[x]已经存储过了, 直接返回即可
    if F[x] != -1:
        return F[x]
    S = set()  # S存储的是可供选择的集合

    for i in range(x):
        j = 0
        while j <= i:  # 规定j不大于i，避免重复
            # 相当于一个局面拆分成了两个局面，由SG函数理论，多个独立局面的SG值，等于这些局面SG值的异或和
            S.add(SG(i) ^ SG(j))
            j += 1

    i = 0
    while True:  # 循环完之后, 可以选出没有出现的最小自然数
        if not S.__contains__(i):
            F[x] = i  # 对F[x]赋值
            return i
        i += 1


if __name__ == '__main__':
    n = int(input())
    A = list(map(int, input().split()))

    res = 0
    for i in range(n):
        res ^= SG(A[i])  # 计算所有堆的异或值,基本原理与Nim游戏相同

    print('Yes' if res >= 1 else 'No')  # res != 0
