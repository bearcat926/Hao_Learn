"""
容斥原理

        由韦恩图推导出计算少量集合时，可推出相关规律：
            |S1∪S2∪S3| = |S1| + |S2| + |S3| - |S1∩S2| - |S1∩S3| - |S2∩S3| + |S1∩S2∩S3|

        由此当数据范围由 3推至 n时，可得：
            |S1∪S2∪...∪Sn| = ∑(i)|Si| - ∑(i, j)|Si∩Sj| + ∑(i, j, k)|Si∩Sj∩Sk| - ....

        归纳整理后，可得结论为：
            对于 k ∈ [1, n] 存在 C(k, 1) - C(k, 2) + C(k, 3) + ... + (-1)^(k-1) * C(k, k) = 1

        证明方法

            1. 数学归纳法
            2. 组合恒等式

        |Sp|的求法：
            |Sp| 为 1-n中 p的倍数的个数
            即 |Sp| = ⌊n/p⌋
            由此可推，当p1, p2互质, |Sp1∩Sp2| = ⌊n/(p1*p2)⌋
            因此 |Sp1∩Sp2∩ ... ∩Spk| = ⌊n/(p1*p2*...*pk)⌋

================================================================
能被整除的数
给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。

请你求出 1∼n 中能被 p1,p2,…,pm 中的至少一个数整除的整数有多少个。

输入格式
第一行包含整数 n 和 m。

第二行包含 m 个质数。

输出格式
输出一个整数，表示满足条件的整数的个数。

数据范围
1 ≤ m ≤ 16,
1 ≤ n, pi ≤ 10^9
输入样例：
10 2
2 3
输出样例：
7
"""

PRIME = []

if __name__ == '__main__':
    n, m = map(int, input().split())
    PRIME = list(map(int, input().split()))
    res = 0
    for i in range(1, 1 << m):  # 使用二进制位运算枚举所有情况
        t, cnt = 1, 0  # t->所有质数的乘积，cnt->当前选法中有几个集合
        for j in range(m):  # 控制位移
            if (i >> j) & 1 == 1:  # 末尾为1
                cnt += 1
                if t * PRIME[j] > n:  # 当前值大于n，即不需要考虑
                    t = -1  # 标记当前结果不可用
                    break
                t *= PRIME[j]
        if t != -1:  # 处理当前结果乘积（使用容斥原理）
            if cnt & 1 == 1:  # 奇数个集合
                res += n // t
            else:  # 偶数个集合
                res -= n // t

    print(res)
