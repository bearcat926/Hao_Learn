"""
KMP字符串
给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串P在模式串S中多次作为子串出现。

求出模板串P在模式串S中所有出现的位置的起始下标。

输入格式
第一行输入整数N，表示字符串P的长度。

第二行输入字符串P。

第三行输入整数M，表示字符串S的长度。

第四行输入字符串S。

输出格式
共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。

数据范围
1≤N≤10^5
1≤M≤10^6
输入样例：
3
aba
5
ababa
输出样例：
0 2

暴力做法：
for i in range(m):
    if S[i:i + n] == P:
        print(i, end=' ')
"""
N, M = 10 ** 5, 10 ** 6
NE = [0] * (N + 10)

if __name__ == '__main__':
    n = int(input())
    # 让下标从1开始
    P = [0] + list(str(input()))
    m = int(input())
    S = [0] + list(str(input()))
    # NEXT[i] => 以i为终点的后缀 和 从1开始的前缀 具有的最长公共子串长度
    # |——————-——————————-——————-——————-——————|
    # |——————|——————————|——————|
    # 1      k          j      i
    #        |——————-——————————|  |—————|
    #                          j j+1
    # 表示为 p[1, j] = p[k, i]
    # 可以直接从j + 1直接进行比较
    # 则NEXT[i] = j + 1

    """
    NEXT[]构造的过程 -> 本质为模式串P的自身匹配，与S串无关
        NEXT[1] = 0 => 单个字符没有公共子串
==============================================================
        以ABABAAABABAA为例子:
        
            i = 2: ABABAAABABAA
                    *
        j + 1 = 1:  ABABAAABABAA
                    *
        NEXT[2] = 0 => 在i = 2时，没有公共子串
==============================================================
            i = 3: ABABAAABABAA
                     *
        j + 1 = 1:   ABABAAABABAA
                     *
        相同则j + 1，NEXT[3] = 1 => 在i = 3时，A为最长公共子串
==============================================================
            i = 4: ABABAAABABAA
                      * 
        j + 1 = 2:   ABABAAABABAA
                      *
        相同则j + 1，NEXT[4] = 2 => 在i = 4时，AB为最长公共子串
==============================================================
            i = 5: ABABAAABABAA
                       * 
        j + 1 = 3:   ABABAAABABAA
                       *
        相同则j + 1，NEXT[5] = 3 => 在i = 5时，ABA为最长公共子串
==============================================================
            i = 6: ABABAAABABAA
                        * 
        j + 1 = 4:   ABABAAABABAA
                        *
        不相同则回退到j = NEXT[j] = NEXT[3] = 1
            i = 6: ABABAAABABAA
                        * 
        j + 1 = 2:     ABABAAABABAA
                        *
        不相同，则NEXT[6] = 1 => 在i = 6时，A为最长公共子串
==============================================================
            i = 7: ABABAAABABAA
                         * 
        j + 1 = 2:      ABABAAABABAA
                         *
        不相同则回退到j = NEXT[j] = NEXT[1] = 0
            i = 7: ABABAAABABAA
                         * 
        j + 1 = 1:       ABABAAABABAA
                         *
        相同则j + 1，NEXT[7] = 1 => 在i = 7时，A为最长公共子串
==============================================================
            i = 8: ABABAAABABAA
                          * 
        j + 1 = 2:       ABABAAABABAA
                          *
        相同则j + 1，NEXT[8] = 2 => 在i = 8时，AB为最长公共子串
==============================================================
            i = 9: ABABAAABABAA
                           * 
        j + 1 = 3:       ABABAAABABAA
                           *
        相同则j + 1，NEXT[9] = 3 => 在i = 9时，ABA为最长公共子串
==============================================================
           i = 10: ABABAAABABAA
                            * 
        j + 1 = 4:       ABABAAABABAA
                            *
        相同则j + 1，NEXT[10] = 4 => 在i = 10时，ABAB为最长公共子串
==============================================================
           i = 11: ABABAAABABAA
                             * 
        j + 1 = 5:       ABABAAABABAA
                             *
        相同则j + 1，NEXT[11] = 5 => 在i = 11时，ABABA为最长公共子串
==============================================================
           i = 12: ABABAAABABAA
                              * 
        j + 1 = 6:       ABABAAABABAA
                              *
        相同则j + 1，NEXT[12] = 6 => 在i = 12时，ABABAA为最长公共子串
    """
    j = 0
    for i in range(2, n + 1):
        while j > 0 and P[i] != P[j + 1]:  # 不行将子串回退到下个最长公共子串的位置
            j = NE[j]
        if P[i] == P[j + 1]:  # 相同就j+1，目的是使两串不移动，比较位置都向后移动一位
            j += 1
        NE[i] = j  # [1, i]子串中的最长公共子串为[1, j]和[i-j+1, i] (之前j+1了)

    # 匹配过程
    j = 0  # P串
    for i in range(1, m + 1):  # S串
        # 匹配过程，本质上与NEXT的过程无异，只是缺少了对NE的赋值
        while j > 0 and S[i] != P[j + 1]:
            j = NE[j]  #
        if S[i] == P[j + 1]:
            j += 1
        # 匹配完成
        if j == n:
            print(i - n, end=' ')
            j = NE[j]
            # 由于此时完成了全P串的匹配工作，
            # 使用j = NE[j]可以找到P串的前后子串的最长公共子串，
            # 并进行移动，以此进行一定的优化

"""
    |——?———-——————————-—————————i——-——————|
       |——————-——————————-——————|
       1                        j = n
    因此S串中匹配串的起始坐标为 i - n + 1
    但由于下标从1开始,结果需要 -1
"""