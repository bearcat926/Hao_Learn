"""
满足条件的01序列
给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，
能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。

输出的答案对 109+7 取模。

输入格式
共一行，包含整数 n。

输出格式
共一行，包含一个整数，表示答案。

数据范围
1 ≤ n ≤ 10^5
输入样例：
3
输出样例：
5
=====================================================
解决方法：

    对于形如 111111000000的序列，若求满足任意前缀序列中 0 的个数都不少于 1 的个数
    则对于坐标轴(x, y)而言，设 0为 x+1 => 向右，1为 y+1 => 向上
    因此符合题目的路径 在(0, 0) 到(6, 6)连成直线 p以下（包含p上）， 即靠近x轴区域的范围
    因此 如下图所示，若路径在由[x, y]组成的直线 q上则该路径不符合要求

    y (0, 7) (1, 7) (2, 7) (3, 7) (4, 7) {5, 7} [6, 7] (7, 7)
    ↑ (0, 6) (1, 6) (2, 6) (3, 6) (4, 6) [5, 6] {6, 6} (7, 6)
      (0, 5) (1, 5) (2, 5) (3, 5) [4, 5] (5, 5) (6, 5) (7, 5)
      (0, 4) (1, 4) (2, 4) [3, 4] (4, 4) (5, 4) (6, 4) (7, 4)
      (0, 3) (1, 3) [2, 3] (3, 3) (4, 3) (5, 3) (6, 3) (7, 3)
      (0, 2) [1, 2] (2, 2) (3, 2) (4, 2) (5, 2) (6, 2) (7, 2)
      [0, 1] (1, 1) (2, 1) (3, 1) (4, 1) (5, 1) (6, 1) (7, 1)
      (0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) -> x

    若路径经过直线q，则对该路径与直线q的交点的后续路径做对称
    可得新路径的终点必为 终点{6, 6}对直线q的对称映射 {5, 7}

    所以对题目的解为 所有过直线p的结果 C(12, 6) 减去 所有过直线q的结果 C(12, 5)
    因此 当序列长度为2n时， res = C(2n, n) - C(2n, n-1)
                            = (2n)!/n!n! - (2n)!/(n-1)!(n+1)!
                            = ((n+1)/n)*(2n)!/(n-1)!(n+1)! - (2n)!/(n-1)!(n+1)!
                            = (1/n)*(2n)!/(n-1)!(n+1)!
                        同理 = (1/n+1)*(2n)!/n!n!   => 卡特兰数
"""
MOD = 10 ** 9 + 7


def qmi(a, p):  # a = a ^ (2 ^ 0)
    k, res = p - 2, 1
    # do ... while
    while k != 0:
        if k & 1 == 1:
            res = res * a % p  # res * a ^ (2 ^ t)
        a = a * a % p  # a ^ (2 ^ t) * a ^ (2 ^ t) =  a ^ (2 ^ t + 2 ^ t) = a ^ (2 ^ t * 2) = a ^ (2 ^ (t + 1))
        k >>= 1
    return res  # 可能会出现 p|a 等价的情况出现


def C(a, b, p):  # C(a, b) = (a * (a-1) * ... * (a - (b - 1))) / (1 * 2 * ... * b)
    res = 1
    i, j = 1, a
    while i <= b:
        res = res * j % p
        res = res * qmi(i, p) % p
        i += 1
        j -= 1
    return res


if __name__ == '__main__':
    n = int(input())
    print(C(2 * n, n, MOD) * qmi(n + 1, MOD) % MOD)