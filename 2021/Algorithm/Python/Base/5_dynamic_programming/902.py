"""
最短编辑距离
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

删除–将字符串 A 中的某个字符删除。
插入–在字符串 A 的某个位置插入某个字符。
替换–将字符串 A 中的某个字符替换为另一个字符。
现在请你求出，将 A 变为 B 至少需要进行多少次操作。

输入格式
第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大写字母。

输出格式
输出一个整数，表示最少操作次数。

数据范围
1 ≤ n, m ≤ 1000
输入样例：
10
AGTCTGACGC
11
AGTAAGTAGGC
输出样例：
4
========================================
状态表示 F(i, j)
    集合：所有将A[1, j] 变成 B[1, j]的操作方式

    属性：MIN

状态计算

    1. 删 -> F[i-1, j] + 1
    2. 增 -> F[i, j-1] + 1
    3. 改 -> F[i-1, j-1] + 1(末尾不相等)/0(末尾已经相等)

    F[i, j] = min(F[i-1, j] + 1, F[i, j-1] + 1, F[i-1, j-1] + k)
"""
N = 1000 + 10
F, A, B = [[0] * N for x in range(N)], [''], ['']

if __name__ == '__main__':
    n = int(input())
    A += list(map(str, input()))
    m = int(input())
    B += list(map(str, input()))
    # 初始化
    for i in range(n + 1):  # 如果a初始长度就是0，那么只能用插入操作让它变成b
        F[i][0] = i
    for j in range(m + 1):  # 如果b的长度是0，那么a只能用删除操作让它变成b
        F[0][j] = j
    # 如果要找 min的话别忘了INF, 要找有负数的 max的话别忘了-INF
    # DP
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            F[i][j] = min(F[i - 1][j] + 1, F[i][j - 1] + 1, F[i - 1][j - 1] + (1 if A[i] != B[j] else 0))
    print(F[n][m])
