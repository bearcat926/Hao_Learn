"""
动态规划

    状态表示 f(i, j)

        集合
            集合表示所有可能，而每一个 f(i, j)都表示集合中的一个属性

        属性
           一般分为 Max, Min, Num

    状态计算 - 集合划分

=======================================
背包问题

    01背包 - 每件物品最多只用一次

    完全背包 - 每件物品有无限个

    多重背包 - 物品有Si个（优化版）

    分组背包 - N组背包中有若干组

=======================================
01背包

    状态 f(i, j)定义：前 i个物品，背包容量 j下的最优解（最大价值）
    条件：
        1. 只从前 i个物品中选
        2. 总体积 <= j

    状态转移方程 f(i, j) = 不含i部分 + 含i部分 = f(i-1, j) + f(i-1, j-vi)


=======================================
01背包问题
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8
"""
N = 1000 + 10
V, W = [0] * N, [0] * N
F = [[0] * N for i in range(N)]

if __name__ == '__main__':
    n, v = map(int, input().split())
    for i in range(n):
        V[i + 1], W[i + 1] = map(int, input().split())
    # dp
    for i in range(1, n + 1):  # [1, n]
        for j in range(v + 1):  # [0, v]
            F[i][j] = F[i - 1][j]  # 第一部分
            if j >= V[i]:  # 第二部分，仅当 j-V[i]>=0成立时才有效
                F[i][j] = max(F[i][j], F[i - 1][j - V[i]] + W[i])  # 找两部分中的最大值
    print(F[n][v])

"""
01背包问题优化 - 滚动数组

将状态 f(i, j)优化到一维 f(j)，实际上只需要做一个等价变形。

为什么可以这样变形呢？我们定义的状态 f(i, j)可以求得任意合法的 i与 j最优解，
但题目只需要求得最终状态f(n, v)，因此我们只需要一维的空间来更新状态。

(1) 状态 f(j)定义：N件物品，背包容量 j下的最优解。

(2) 注意枚举背包容量 j必须从 v开始。

(3) 为什么一维情况下枚举背包容量需要逆序？
    在二维情况下，状态 f(i, j)可以由上一轮 f(i-1, j)的状态得来的，而 f(i, j)与 f(i-1, j)是独立的。
    而优化到一维后，如果还是正序，则有 f[较小体积]推导 f[较大体积]，因此无法保证与二维情况相同。
    若使用逆序，由于先处理 f[较大体积]，则当前 f(j)仍然为 f(i-1, j)的结果，为被 i处理过
    因此结果符合二维的推断结论
    简单来说，一维情况正序更新状态 f(j)需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i])
"""
N = 1000 + 10
V, W = [0] * N, [0] * N
F = [0] * N

if __name__ == '__main__':
    n, v = map(int, input().split())
    for i in range(n):
        V[i + 1], W[i + 1] = map(int, input().split())
    # dp
    for i in range(1, n + 1):  # [1, n]
        for j in range(v, V[i] - 1, -1):  # [v, V[i]]
            F[j] = max(F[j], F[j - V[i]] + W[i])
    print(F[v])