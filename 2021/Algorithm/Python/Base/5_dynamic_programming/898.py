"""
数字三角形
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
输入格式
第一行包含整数 n，表示数字三角形的层数。

接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

输出格式
输出一个整数，表示最大的路径数字和。

数据范围
1 ≤ n ≤ 500,
−10000 ≤ 三角形中的整数 ≤ 10000
输入样例：
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
输出样例：
30
=====================================
状态表示 f(i, j)

    集合：所有从起点走到 (i, j)的路径

    属性：max

状态计算

    f(i, j) = max(f(i-1, j-1), f(i-1, j)) + G[i][j]

"""
N = 500 + 10
INF = -10 ** 9
F = [[INF] * N for i in range(1, N + 1)]  # 需要全部初始化
G = [[0] * i for i in range(1, N + 1)]

if __name__ == '__main__':
    n = int(input())
    for i in range(1, n + 1):
        G[i] = [0] + list(map(int, input().split()))
    # dp
    res = 0
    F[1][1] = G[1][1]  # 第一层不需要计算，从第二层开始
    for i in range(2, n + 1):  # 层数
        for j in range(1, i + 1):  # 每层的元素数 [1, i]
            F[i][j] = max(F[i - 1][j - 1], F[i - 1][j]) + G[i][j]
            if i == n:  # 在最后一层计算最大值
                res = max(res, F[i][j])
    print(res)
