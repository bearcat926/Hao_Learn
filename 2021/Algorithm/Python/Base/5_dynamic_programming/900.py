"""
整数划分
一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

输入格式
共一行，包含一个整数 n。

输出格式
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 10^9+7 取模。

数据范围
1 ≤ n ≤ 1000
输入样例:
5
输出样例：
7
=======================================
等同于一个完全背包问题

容量为n, 每件物品有无限个, 求恰好装满背包的方案数

状态表示

    集合：体积v在[1, i]的范围中选择累加和为 j的所有选法

    属性：NUM

状态计算

    0：F[i-1][j]
    1：F[i-1][j - i]
    2：F[i-1][j - i * 2]
    ...
    s：F[i-1][j - i * s]  (满足 j > i * s 的最大值s)

    F[i][j]     = F[i-1][j]     + F[i-1][j - i] + F[i-1][j - i * 2] + ... + F[i-1][j - i * s]
    F[i][j - i] =                 F[i-1][j - i] + F[i-1][j - i * 2] + ... + F[i-1][j - i * s]

    因此 F[i][j] = F[i-1][j] + F[i][j - i]
    由于被选择的物品体积i可以省略，二维转一维后，F[j] = F[j] + F[j - i]
"""
N = 1000 + 10
F = [0] * N
MOD = 10 ** 9 + 7

if __name__ == '__main__':
    n = int(input())
    F[0] = 1
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            F[j] = (F[j] + F[j - i]) % MOD
    print(F[n])
